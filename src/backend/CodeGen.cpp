#include "CodeGen.hpp"
#include "fsm.hpp"
#include "state.hpp"
#include "transition.hpp"
#include "variable.hpp"
#include <QDebug>
#include <QRegularExpression>
#include <csignal>

/**
 * @brief Constructor for the CodeGen class
 * @param parent The parent QObject
 */
CodeGen::CodeGen(QObject *parent) : QObject(parent)
{
}

/**
 * @brief Generates complete C++ code from a state machine
 * 
 * This is the main entry point for code generation. It orchestrates the 
 * generation process by calling the specialized generation methods for
 * different parts of the code.
 * 
 * @param fsm The state machine to generate code from
 * @return Generated C++ code as a QString
 */
QString CodeGen::generateCode(FSM *fsm)
{
    QString code;

    // Generate file header with automaton info
    code += "/**\n";
    code += " * Generated Finite State Machine: " + fsm->getName() + "\n";
    
    // Add description if available
    QString description = fsm->getComment();
    if (!description.isEmpty()) {
        code += " * Description: " + description + "\n";
    }
    
    code += " * \n";
    code += " * This file was automatically generated by ICP FSM Code Generator\n";
    code += " */\n\n";

    // Generate the various code sections
    code += generateHeaders();
    code += generateVariableDeclarations(fsm);
    code += generateRuntimeMonitoring();
    code += generateHelperFunctions();
    code += generateQStateMachineMain(fsm);

    return code;
}

/**
 * @brief Generates standard C++ header includes
 * 
 * Creates the include statements needed for the generated code, 
 * focusing on Qt libraries for platform independence.
 * 
 * @return Code section as QString
 */
QString CodeGen::generateHeaders()
{
    QString code;
    
    // Use Qt libraries for platform independence
    code += "#include <QtCore/QDebug>\n";
    code += "#include <QtCore/QString>\n";
    code += "#include <QtCore/QMap>\n";
    code += "#include <QtCore/QDateTime>\n";
    code += "#include <QtCore/QCoreApplication>\n";
    code += "#include <QtCore/QTimer>\n";
    code += "#include <QtCore/QSocketNotifier>\n";
    code += "#include <QtCore/QStateMachine>\n";
    code += "#include <QtCore/QState>\n";
    code += "#include <QtCore/QEvent>\n";
    code += "#include <QtCore/QAbstractTransition>\n";
    code += "#include <stdio.h>\n";
    code += "#include <unistd.h>\n";
    code += "#include <csignal>\n";
    code += "\n";
    
    return code;
}

/**
 * @brief Generates helper functions for FSM operations
 * 
 * Creates utility functions that assist with state machine operations,
 * such as input value retrieval, type conversion, and output generation.
 * 
 * @return Code section as QString
 */
QString CodeGen::generateHelperFunctions()
{
    QString code;
    
    code += "/******************************************************************************\n";
    code += " * Helper functions for FSM operations\n";
    code += " ******************************************************************************/\n\n";
    
    // Gets the string value of an input
    code += "/**\n";
    code += " * @brief Gets the string value of an input\n";
    code += " * @param input Input name\n";
    code += " * @return Current string value of the input, or empty string if not found\n";
    code += " */\n";
    code += "QString valueof(const QString &input) {\n";
    code += "    if (inputs.contains(input)) {\n";
    code += "        return inputs[input];\n";
    code += "    }\n";
    code += "    return QString();\n";
    code += "}\n\n";
    
    // Convert string to int safely
    code += "/**\n";
    code += " * @brief Safely converts a string to an integer\n";
    code += " * @param str String to convert\n";
    code += " * @return Integer value, or 0 if conversion fails\n";
    code += " */\n";
    code += "int atoi_safe(const QString &str) {\n";
    code += "    bool ok = false;\n";
    code += "    int value = str.toInt(&ok);\n";
    code += "    return ok ? value : 0;\n";
    code += "}\n\n";
    
    // Check if input exists and has value
    code += "/**\n";
    code += " * @brief Checks if an input is defined and has a non-empty value\n";
    code += " * @param input Input name to check\n";
    code += " * @return True if the input exists and has a value\n";
    code += " */\n";
    code += "bool defined(const QString &input) {\n";
    code += "    return inputs.contains(input) && !inputs[input].isEmpty();\n";
    code += "}\n\n";
    
    // Output function
    code += "/**\n";
    code += " * @brief Sends an output value to a specific port\n";
    code += " * @param port Output port name\n";
    code += " * @param value Integer value to send\n";
    code += " */\n";
    code += "void output(const QString &port, int value) {\n";
    code += "    outputs[port] = QString::number(value);\n";
    code += "    logOutputEvent(port, QString::number(value));\n";
    code += "}\n\n";

    // Update function to clear trigger-type inputs dynamically
    code += "/**\n";
    code += " * @brief Clears trigger-type inputs after they've been processed\n";
    code += " * @details Inputs that are used as triggers/events should be cleared after processing\n";
    code += " *          so they don't repeatedly trigger on subsequent cycles\n";
    code += " */\n";
    code += "void clearTriggerInputs() {\n";
    code += "    // For any input that has a value, clear it after processing\n";
    code += "    QStringList inputsToReset;\n";
    code += "    \n";
    code += "    // First identify which inputs need clearing to avoid modifying while iterating\n";
    code += "    for (auto it = inputs.constBegin(); it != inputs.constEnd(); ++it) {\n";
    code += "        if (!it.value().isEmpty()) {\n";
    code += "            inputsToReset << it.key();\n";
    code += "        }\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Now clear the identified inputs\n";
    code += "    if (!inputsToReset.isEmpty()) {\n";
    code += "        \n";
    code += "        for (const QString& input : inputsToReset) {\n";
    code += "            inputs[input] = QString();\n";
    code += "        }\n";
    code += "    }\n";
    code += "}\n\n";
    
    return code;
}

/**
 * @brief Generates global variable declarations
 * 
 * Creates declarations for core state machine variables and any custom
 * variables defined in the state machine.
 * 
 * @param fsm State machine containing variable definitions
 * @return Code section as QString
 */
QString CodeGen::generateVariableDeclarations(FSM *fsm)
{
    QString code;
    
    code += "/******************************************************************************\n";
    code += " * Variable declarations\n";
    code += " ******************************************************************************/\n\n";
    
    // Core state machine variables
    code += "QMap<QString, QString> inputs;      // Map of input names to values\n";
    code += "QMap<QString, QString> outputs;     // Map of output names to values\n\n";
    
    // Extract custom variables from FSM
    QMap<QString, Variable*> variables = fsm->getVariables();
    if (!variables.isEmpty()) {
        code += "// Custom variables for " + fsm->getName() + "\n";
        
        for (auto it = variables.constBegin(); it != variables.constEnd(); ++it) {
            Variable* var = it.value();
            code += var->getType() + " " + var->getName() + " = " + var->getValue().toString() + ";\n";
        }
        code += "\n";
    }
    
    return code;
}

/**
 * @brief Generates monitoring and debugging functions
 * 
 * Creates functions for runtime monitoring of the state machine,
 * including state transitions, input/output events, and general
 * debugging utilities.
 * 
 * @return Code section as QString
 */
QString CodeGen::generateRuntimeMonitoring()
{
    QString code;
    
    // Add section header comment
    code += "/******************************************************************************\n";
    code += " * Runtime monitoring and debugging\n";
    code += " ******************************************************************************/\n\n";

    // Enhanced cosmic color palette - much richer and more vibrant
    code += "// ANSI basic formatting codes\n";
    code += "const QString ANSI_RESET = \"\\033[0m\";\n";
    code += "const QString ANSI_BOLD = \"\\033[1m\";\n";
    code += "const QString ANSI_DIM = \"\\033[2m\";\n";
    code += "const QString ANSI_ITALIC = \"\\033[3m\";\n";
    code += "const QString ANSI_UNDERLINE = \"\\033[4m\";\n\n";
    
    // Primary cosmic palette - deep space inspired
    code += "// Primary cosmic palette\n";
    code += "const QString DEEP_SPACE = \"\\033[38;5;17m\";       // Dark blue-black of deep space\n";
    code += "const QString COSMIC_PURPLE = \"\\033[38;5;93m\";    // Rich cosmic purple, used for state names & headers\n";
    code += "const QString NEBULA_BLUE = \"\\033[38;5;39m\";      // Bright nebula blue, used for transition info and info level logs\n";
    code += "const QString SPACE_TEAL = \"\\033[38;5;31m\";       // Deep space teal, used for input values\n";
    code += "const QString NEBULA_PINK = \"\\033[38;5;169m\";     // Bright nebula pink, used for output values\n";
    code += "const QString STARDUST = \"\\033[38;5;153m\";        // Light blue stardust, used for variable values\n";
    code += "const QString STAR_WHITE = \"\\033[38;5;231m\";      // Bright star white, used for command headers\n";
    code += "const QString COSMIC_DUST = \"\\033[38;5;102m\";     // Faded cosmic dust, used for source states and notice level logs\n\n";
    
    // Accent colors - for special highlights and alerts
    code += "// Accent colors\n";
    code += "const QString STELLAR_PURPLE = \"\\033[38;5;141m\";  // Bright stellar purple, used for section headers\n";
    code += "const QString PULSAR_YELLOW = \"\\033[38;5;220m\";   // Pulsating yellow, used for warnings\n";
    code += "const QString QUANTUM_GREEN = \"\\033[38;5;84m\";    // Quantum field green, used for target states and success messages\n";
    code += "const QString WARP_RED = \"\\033[38;5;196m\";        // Warp field red, used for error messages\n\n";

    // Semantic color mappings
    code += "// Semantic color mappings - function-based color assignments\n";
    code += "const QString COLOR_STATE = COSMIC_PURPLE;        // State names & headers\n";
    code += "const QString COLOR_TRANSITION = NEBULA_BLUE;     // Transition information\n";
    code += "const QString COLOR_SOURCE = COSMIC_DUST;         // Source states\n";
    code += "const QString COLOR_TARGET = QUANTUM_GREEN;       // Target states\n";
    code += "const QString COLOR_INPUT = SPACE_TEAL;           // Input values\n";
    code += "const QString COLOR_OUTPUT = NEBULA_PINK;         // Output values\n";
    code += "const QString COLOR_COMMAND = STAR_WHITE;         // Command headers\n";
    code += "const QString COLOR_VALUE = STARDUST;             // Variable values\n";
    code += "const QString COLOR_INFO = NEBULA_BLUE;           // Info level logs\n";
    code += "const QString COLOR_NOTICE = COSMIC_DUST;         // Notice level logs\n";
    code += "const QString COLOR_WARNING = PULSAR_YELLOW;      // Warning level logs\n";
    code += "const QString COLOR_ERROR = WARP_RED;             // Error level logs\n";
    code += "const QString COLOR_SUCCESS = QUANTUM_GREEN;      // Success messages\n";
    code += "const QString COLOR_HEADER = STELLAR_PURPLE;      // Section headers\n\n";

    // Symbols for marking elements
    code += "// Symbols for marking elements\n";
    code += "const QString SYM_BULLET = \"•\";       // Primary bullet point\n";
    code += "const QString SYM_BULLET_2 = \"◦\";     // Secondary bullet point\n";
    code += "const QString SYM_STAR = \"✧\";         // Star/asterisk \n";
    code += "const QString SYM_TRIANGLE = \"▶\";     // Triangle pointer\n";
    code += "const QString SYM_ARROW = \"→\";        // Right arrow\n";
    code += "const QString SYM_SUCCESS = \"✓\";      // Success checkmark\n";
    code += "const QString SYM_ERROR = \"✗\";        // Error symbol\n\n";

    // Predefined UI elements using the cosmic colors
    code += "// Predefined UI elements \n";
    code += "const QString STATE_HEADER = ANSI_BOLD + COLOR_STATE + \"════════ STATE: \" + ANSI_RESET;\n";
    code += "const QString COMMAND_HEADER = ANSI_BOLD + COLOR_COMMAND + \"⟫ COMMAND: \" + ANSI_RESET;\n";
    code += "const QString SECTION_SEPARATOR = COLOR_NOTICE + \"───────────────────────────────────────────────────\" + ANSI_RESET;\n";
    code += "const QString DOUBLE_SEPARATOR = COLOR_TRANSITION + \"═══════════════════════════════════════════════════\" + ANSI_RESET;\n\n";

    // Legacy color mappings for backward compatibility
    code += "// Legacy color mappings for backward compatibility\n";
    code += "const QString ANSI_MAGENTA = WARP_RED;\n";
    code += "const QString ANSI_VOID_PURPLE = COLOR_STATE;\n";
    code += "const QString ANSI_OBLIVION_BLUE = COLOR_TRANSITION;\n";
    code += "const QString ANSI_SILVER = COSMIC_DUST;\n";
    code += "const QString ANSI_CELESTIAL_WHITE = STAR_WHITE;\n";
    code += "const QString ANSI_RED = WARP_RED;\n";
    code += "const QString ANSI_GREEN = QUANTUM_GREEN;\n";
    code += "const QString ANSI_YELLOW = PULSAR_YELLOW;\n";
    code += "const QString ANSI_BLUE = NEBULA_BLUE;\n";
    code += "const QString ANSI_CYAN = SPACE_TEAL;\n";
    code += "const QString ANSI_WHITE = STAR_WHITE;\n\n";

    // State change logging function with enhanced colors
    code += "/**\n";
    code += " * @brief Logs state transitions for monitoring\n";
    code += " * @param fromState Source state name\n";
    code += " * @param toState Target state name\n";
    code += " */\n";
    code += "void logStateChange(const QString& fromState, const QString& toState) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"\";\n";  // Add empty line before state change for separation\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" \n";
    code += "             << ANSI_BOLD + COLOR_TRANSITION + \"STATE CHANGE\" + ANSI_RESET + \": \"\n";
    code += "             << COLOR_SOURCE + fromState + ANSI_RESET \n";
    code += "             << \" \" + SYM_ARROW + \" \" \n";
    code += "             << ANSI_BOLD + COLOR_TARGET + toState + ANSI_RESET;\n";
    code += "}\n\n";
    
    // Input event logging function with enhanced colors
    code += "/**\n";
    code += " * @brief Logs input values for monitoring\n";
    code += " * @param input Input name\n";
    code += " * @param value Input value\n";
    code += " */\n";
    code += "void logInputEvent(const QString& input, const QString& value) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\"\n";
    code += "             << COLOR_INPUT + SYM_BULLET + \" INPUT\" + ANSI_RESET + \": \"\n";
    code += "             << \"  \" + ANSI_BOLD + input + ANSI_RESET \n";
    code += "             << \" = \" \n";
    code += "             << COLOR_VALUE + value + ANSI_RESET;\n";
    code += "}\n\n";
    
    // Output event logging function with enhanced colors
    code += "/**\n";
    code += " * @brief Logs output values for monitoring\n";
    code += " * @param output Output name\n";
    code += " * @param value Output value\n";
    code += " */\n";
    code += "void logOutputEvent(const QString& output, const QString& value) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\"\n";
    code += "             << COLOR_OUTPUT + SYM_BULLET + \" OUT \" + ANSI_RESET + \": \"\n";
    code += "             << \"\" + ANSI_BOLD + output + ANSI_RESET \n";
    code += "             << \"=\" \n";
    code += "             << COLOR_VALUE + value + ANSI_RESET;\n";
    code += "}\n\n";
    
    // Debug print function with enhanced colors for different log levels
    code += "/**\n";
    code += " * @brief Prints a debug message with timestamp\n";
    code += " * @param message Debug message to display\n";
    code += " * @param level Debug level (0=INFO, 1=NOTICE, 2=WARNING, 3=ERROR)\n";
    code += " */\n";
    code += "void debugPrint(const QString& message, int level = 0) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    QString prefix;\n";
    code += "    switch (level) {\n";
    code += "        case 0: prefix = COLOR_INFO + SYM_BULLET + \" INFO\" + ANSI_RESET + \": \"; break;\n";
    code += "        case 1: prefix = COLOR_NOTICE + SYM_BULLET + \" NOTICE\" + ANSI_RESET + \": \"; break;\n";
    code += "        case 2: prefix = COLOR_WARNING + SYM_TRIANGLE + \" WARNING\" + ANSI_RESET + \": \"; break;\n";
    code += "        case 3: prefix = COLOR_ERROR + SYM_ERROR + \" ERROR\" + ANSI_RESET + \": \"; break;\n";
    code += "        default: prefix = \"DEBUG: \";\n";
    code += "    }\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" << prefix << message;\n";
    code += "}\n\n";

    // Add the showHelp function to display commands and valid inputs
    code += "/**\n";
    code += " * @brief Displays all available commands and valid inputs in a formatted way\n";
    code += " * @param validInputs Set of valid input names for this state machine\n";
    code += " * @param helpLines List of command descriptions to display\n";
    code += " */\n";
    code += "void showHelp(const QSet<QString>& validInputs, const QStringList& helpLines) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" << ANSI_BOLD + NEBULA_BLUE + \"AVAILABLE COMMANDS\" + ANSI_RESET;\n";
    code += "    qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "    \n";
    code += "    // Display command help lines\n";
    code += "    for (const QString& line : helpLines) {\n";
    code += "        qDebug().noquote() << line;\n";
    code += "    }\n";
    code += "    \n";
    code += "    // Display valid inputs section if there are any\n";
    code += "    if (!validInputs.isEmpty()) {\n";
    code += "        qDebug().noquote() << \"\\n\" + ANSI_BOLD + STELLAR_PURPLE + \"VALID INPUTS:\" + ANSI_RESET;\n";
    code += "        \n";
    code += "        // Sort inputs for a more predictable display\n";
    code += "        QStringList sortedInputs = validInputs.values();\n";
    code += "        sortedInputs.sort();\n";
    code += "        \n";
    code += "        // Display inputs as a simple list\n";
    code += "        for (const QString& input : sortedInputs) {\n";
    code += "            qDebug().noquote() << \"  \" + SPACE_TEAL + input + ANSI_RESET;\n";
    code += "        }\n";
    code += "    }\n";
    code += "    \n";
    code += "    qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "}\n\n";

    return code;
}

/**
 * @brief Generate code for a transition
 * @param transition The transition
 * @param sourceState Source state
 * @param targetState Target state
 * @return Generated C++ code for the transition
 */
QString CodeGen::generateTransitionCode(Transition *transition, 
                                     const State *sourceState, 
                                     const State *targetState) {
    QString code;
    QString sourceName = const_cast<State*>(sourceState)->getName();
    QString targetName = const_cast<State*>(targetState)->getName();
    QString sourceLower = sourceName.toLower();
    QString targetLower = targetName.toLower();
    
    // Get transition properties
    QString condition = transition->getCondition();
    int delay = transition->isDelayedTransition() ? transition->getDelay() : 0;
    bool hasCondition = !condition.isEmpty();
    bool hasDelay = delay > 0;
    
    // Variable name for the transition
    QString transName = sourceLower + "To" + targetName + "Transition";
    
    // Create the unified transition - FIX: Remove color constants that aren't accessible here
    code += "    // Create unified transition: " + sourceName + " → " + targetName;
    
    // Add condition and/or delay information to the comment
    if (hasCondition || hasDelay) {
        code += " (";
        if (hasCondition) {
            code += "[ " + condition + " ]";
        }
        if (hasDelay) {
            if (hasCondition) code += " ";
            code += "@ " + QString::number(delay) + "ms";
        }
        code += ")";
    }
    code += "\n";
    
    // Create the transition object
    code += "    UnifiedTransition* " + transName + " = new UnifiedTransition(";
    
    // Add condition lambda if present
    if (hasCondition) {
        code += "[]() -> bool {\n";
        code += "        // Evaluate condition: " + condition + "\n";
        code += "        return " + condition + ";\n";
        code += "    }";
    } else {
        code += "[]() { return true; }"; // Default condition always true
    }
    
    // Add delay if present
    code += ", " + QString::number(delay);
    
    // Add source and target state names for logging
    code += ", \"" + sourceName + "\", \"" + targetName + "\"";
    
    // Add condition string for logging
    if (hasCondition) {
        code += ", \"" + condition.replace("\"", "\\\"") + "\"";
    }
    
    code += ");\n";
    
    // Add the transition to the state machine
    code += "    " + sourceLower + "State->addTransition(" + transName + ");\n";
    code += "    " + transName + "->setTargetState(" + targetLower + "State);\n\n";
    
    return code;
}

/**
 * @brief Generates a main function that uses QStateMachine
 * 
 * Creates the main function that uses Qt's built-in QStateMachine rather
 * than a manual switch-case approach. This leverages Qt's state machine framework
 * for cleaner code and better integration with Qt's event system.
 * 
 * @param fsm FSM containing the states and transitions
 * @return Code section as QString
 */
QString CodeGen::generateQStateMachineMain(FSM *fsm)
{
    QString code;
    
    // Add section header comment
    code += "/******************************************************************************\n";
    code += " * Main function with QStateMachine\n";
    code += " ******************************************************************************/\n\n";

    // Get the initial state
    State *initial = fsm->getInitialState();
    QMap<QString, State*> allStates = fsm->getStates();
    
    QString initialStateName = initial ? initial->getName() : "UNKNOWN";

    // Define the classes needed for QStateMachine
    code += "/**\n";
    code += " * @brief Unified transition class handling both conditions and delays\n";
    code += " */\n";
    code += "class UnifiedTransition : public QAbstractTransition {\n";
    code += "public:\n";
    code += "    /**\n";
    code += "     * @brief Constructor for a unified transition that handles both conditions and delays\n";
    code += "     * @param condition A lambda function that evaluates to a boolean\n";
    code += "     * @param delayMs Delay in milliseconds before triggering the transition (0 = no delay)\n";
    code += "     * @param fromState Source state name (for logging)\n";
    code += "     * @param toState Target state name (for logging)\n";
    code += "     * @param conditionStr String representation of the condition (for logging)\n";
    code += "     */\n";
    code += "    explicit UnifiedTransition(std::function<bool()> condition = []() { return true; },\n";
    code += "                             int delayMs = 0,\n";
    code += "                             const QString& fromState = QString(),\n";
    code += "                             const QString& toState = QString(),\n";
    code += "                             const QString& conditionStr = QString())\n";
    code += "        : m_condition(std::move(condition)),\n";
    code += "          m_delay(delayMs),\n";
    code += "          m_fromState(fromState),\n";
    code += "          m_toState(toState),\n";
    code += "          m_conditionStr(conditionStr),\n";
    code += "          m_timer(nullptr),\n";
    code += "          m_conditionMet(false)\n";
    code += "    {\n";
    code += "        if (m_delay > 0) {\n";
    code += "            m_timer = new QTimer(this);\n";
    code += "            m_timer->setSingleShot(true);\n";
    code += "            connect(m_timer, &QTimer::timeout, this, &UnifiedTransition::triggerTransition);\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "protected:\n";
    code += "    /**\n";
    code += "     * @brief Tests whether the transition should be triggered\n";
    code += "     * @param event The event triggering the transition\n";
    code += "     * @return True if the transition should occur, false otherwise\n";
    code += "     */\n";
    code += "    bool eventTest(QEvent* event) override {\n";
    code += "        // If this is our custom timeout event and the condition was met previously\n";
    code += "        if (event->type() == QEvent::User + 1 && m_conditionMet) {\n";
    code += "            return true;\n";
    code += "        }\n";
    code += "        \n";
    code += "        // For all other events, we check the condition\n";
    code += "        try {\n";
    code += "            m_conditionMet = m_condition();\n";
    code += "            \n";
    code += "            // If condition failed, stop any running timer and return false\n";
    code += "            if (!m_conditionMet) {\n";
    code += "                cancelTimerIfActive();\n";
    code += "                return false;\n";
    code += "            }\n";
    code += "            \n";
    code += "            // Condition passed - if we have a delay, start the timer (if not already running)\n";
    code += "            if (m_delay > 0) {\n";
    code += "                if (m_timer && !m_timer->isActive()) {\n";
    code += "                    logTransitionStart();\n";
    code += "                    m_timer->start(m_delay);\n";
    code += "                }\n";
    code += "                return false; // Don't trigger yet, wait for timer\n";
    code += "            }\n";
    code += "            \n";
    code += "            // No delay, trigger immediately\n";
    code += "            return m_conditionMet;\n";
    code += "        } catch (const std::exception& e) {\n";
    code += "            debugPrint(\"Error evaluating transition condition: \" + QString::fromStdString(e.what()), 3);\n";
    code += "            return false;\n";
    code += "        } catch (...) {\n";
    code += "            debugPrint(\"Unknown error evaluating transition condition\", 3);\n";
    code += "            return false;\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "    /**\n";
    code += "     * @brief Logs the transition when it occurs\n";
    code += "     * @param event The event triggering the transition\n";
    code += "     */\n";
    code += "    void onTransition(QEvent* event) override {\n";
    code += "        Q_UNUSED(event);\n";
    code += "        \n";
    code += "        debugPrint(DOUBLE_SEPARATOR);\n";
    code += "        debugPrint(\"Transition: \" + \n";
    code += "                  ANSI_BOLD + COSMIC_DUST + m_fromState + ANSI_RESET + \n";
    code += "                  \" \" + SYM_ARROW + \" \" + \n";
    code += "                  ANSI_BOLD + QUANTUM_GREEN + m_toState + ANSI_RESET);\n";
    code += "        \n";
    code += "        if (!m_conditionStr.isEmpty()) {\n";
    code += "            debugPrint(\"  Condition satisfied: \" + COLOR_NOTICE + m_conditionStr + ANSI_RESET);\n";
    code += "        }\n";
    code += "        \n";
    code += "        if (m_delay > 0) {\n";
    code += "            debugPrint(\"  Delay completed: \" + COLOR_VALUE + QString::number(m_delay) + \"ms\" + ANSI_RESET);\n";
    code += "        }\n";
    code += "        debugPrint(SECTION_SEPARATOR);\n";
    code += "        \n";
    code += "        // Reset condition state after transition\n";
    code += "        m_conditionMet = false;\n";
    code += "    }\n\n";
    
    code += "private slots:\n";
    code += "    /**\n";
    code += "     * @brief Triggers the transition after the delay timer expires\n";
    code += "     */\n";
    code += "    void triggerTransition() {\n";
    code += "        // We only want to post the event if the condition is still true\n";
    code += "        if (m_condition()) {\n";
    code += "            QEvent* customEvent = new QEvent(static_cast<QEvent::Type>(QEvent::User + 1));\n";
    code += "            machine()->postEvent(customEvent);\n";
    code += "        } else {\n";
    code += "            m_conditionMet = false;\n";
    code += "            debugPrint(\"Condition no longer valid after delay for transition \" + \n";
    code += "                      m_fromState + \" → \" + m_toState + \n";
    code += "                      \", not triggering\");\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "private:\n";
    code += "    /**\n";
    code += "     * @brief Helper method to cancel the timer if it's active\n";
    code += "     */\n";
    code += "    void cancelTimerIfActive() {\n";
    code += "        if (m_timer && m_timer->isActive()) {\n";
    code += "            m_timer->stop();\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "    /**\n";
    code += "     * @brief Helper method to log transition start with consistent formatting\n";
    code += "     */\n";
    code += "    void logTransitionStart() {\n";
    code += "        debugPrint(\"Condition met for transition \" + \n";
    code += "                  COSMIC_DUST + m_fromState + ANSI_RESET + \" \" + SYM_ARROW + \" \" + \n";
    code += "                  QUANTUM_GREEN + m_toState + ANSI_RESET + \n";
    code += "                  \", starting \" + STARDUST + QString::number(m_delay) + \"ms\" + ANSI_RESET + \" delay timer\");\n";
    code += "    }\n\n";
    
    code += "    std::function<bool()> m_condition;  ///< The condition to evaluate\n";
    code += "    int m_delay;                        ///< Delay in milliseconds (0 = no delay)\n";
    code += "    QString m_fromState;                ///< Source state name for logging\n";
    code += "    QString m_toState;                  ///< Target state name for logging\n";
    code += "    QString m_conditionStr;             ///< Condition string for logging\n";
    code += "    QTimer* m_timer;                    ///< Timer for delayed transitions\n";
    code += "    bool m_conditionMet;                ///< Tracks whether the condition was met\n";
    code += "};\n\n";

    code += "/**\n";
    code += " * @brief Custom event for input changes\n";
    code += " */\n";
    code += "class InputEvent : public QEvent {\n";
    code += "public:\n";
    code += "    static const QEvent::Type InputChangedType = static_cast<QEvent::Type>(QEvent::User + 2);\n\n";
    
    code += "    InputEvent(const QString& name, const QString& value) \n";
    code += "        : QEvent(InputChangedType), m_name(name), m_value(value) {}\n\n";
    
    code += "    QString name() const { return m_name; }\n";
    code += "    QString value() const { return m_value; }\n\n";
    
    code += "private:\n";
    code += "    QString m_name;\n";
    code += "    QString m_value;\n";
    code += "};\n\n";

    code += "/**\n";
    code += " * @brief Main function that uses QStateMachine for state management\n";
    code += " */\n";
    code += "int main(int argc, char *argv[]) {\n";
    code += "    QCoreApplication app(argc, argv);\n";
    code += "    \n";
    code += "    qDebug().noquote() << \"\\n\" + DOUBLE_SEPARATOR;\n";
    code += "    qDebug().noquote() << ANSI_BOLD + COLOR_HEADER + SYM_STAR + \" \" + SYM_STAR + \" \" + SYM_STAR + \"  OBLIVION STATE MACHINE  \" + SYM_STAR + \" \" + SYM_STAR + \" \" + SYM_STAR + ANSI_RESET;\n";
    code += "    qDebug().noquote() << COLOR_TRANSITION + \"     Navigating the infinite expanse of software states\" + ANSI_RESET;\n";
    code += "    qDebug().noquote() << DOUBLE_SEPARATOR + \"\\n\";\n";
    code += "    \n";
    code += "    debugPrint(\"Starting FSM application with QStateMachine\");\n";
    code += "    debugPrint(\"State machine name: \" + ANSI_BOLD + COLOR_STATE + \"" + fsm->getName() + "\" + ANSI_RESET);\n";
    
    // Add signal handler for SIGINT (Ctrl+C)
    code += "    // Setup signal handler for Ctrl+C (SIGINT)\n";
    code += "    std::signal(SIGINT, [](int) {\n";
    code += "        qDebug().noquote() << \"\";\n";
    code += "        debugPrint(ANSI_BOLD + COLOR_ERROR + \"Interrupt received. Exiting gracefully...\" + ANSI_RESET);\n";
    code += "        QCoreApplication::quit();\n";
    code += "    });\n\n";

    // Extract and initialize inputs/outputs
    QSet<QString> inputNames = fsm->getInputs();
    QSet<QString> outputNames = fsm->getOutputs();
    
    code += "    // Initialize inputs and outputs\n";
    for (const QString& input : inputNames) {
        code += "    inputs[QStringLiteral(\"" + input.trimmed() + "\")] = QString();\n";
    }
    
    for (const QString& output : outputNames) {
        code += "    outputs[QStringLiteral(\"" + output.trimmed() + "\")] = QString();\n";
    }
    code += "\n";

    // Create a global set for valid input names to use for validation
    code += "    // Create a set of valid input names for validation\n";
    code += "    QSet<QString> validInputNames;\n";
    for (const QString& input : inputNames) {
        code += "    validInputNames.insert(QStringLiteral(\"" + input.trimmed() + "\"));\n";
    }
    code += "\n";
    
    code += "    // Define help text once to avoid duplication\n";
    code += "    const QStringList helpLines = {\n";
    code += "        \"• \" + ANSI_BOLD + QString(\"input_name=value\").leftJustified(26) + ANSI_RESET + \"- Set an input value\",\n";
    code += "        \"• \" + ANSI_BOLD + QString(\"input_name\").leftJustified(26) + ANSI_RESET + \"- Set an input with default value 'true'\",\n";
    code += "        \"• \" + ANSI_BOLD + QString(\"status\").leftJustified(26) + ANSI_RESET + \"- Show the current system state\",\n";
    code += "        \"• \" + ANSI_BOLD + QString(\"help\").leftJustified(26) + ANSI_RESET + \"- Show this help message\",\n";
    code += "        \"• \" + ANSI_BOLD + QString(\"quit/exit\").leftJustified(26) + ANSI_RESET + \"- Exit the application\"\n";
    code += "    };\n\n";

    // Create the state machine object
    code += "    // Create state machine\n";
    code += "    QStateMachine fsm;\n";
    code += "    fsm.setObjectName(\"" + fsm->getName() + "\");\n\n";
    
    // Enhanced state creation display
    code += "    // Create all states\n";
    code += "    debugPrint(\"Creating states...\");\n";

    // Iterate through states using the map from FSM
    for (auto it = allStates.begin(); it != allStates.end(); ++it) {
        State* state = it.value();
        QString stateName = state->getName();
        QString stateLower = stateName.toLower();
        
        code += "    QState* " + stateLower + "State = new QState(&fsm);\n";
        code += "    " + stateLower + "State->setObjectName(\"" + stateName + "\");\n";
        code += "    debugPrint(\"  Created state: \" + COLOR_STATE + \"" + stateName + "\" + ANSI_RESET);\n";
        
        // Add onEntry code if available and clear trigger inputs after execution
        QString onEntry = state->getCode();
        if (!onEntry.isEmpty()) {
            code += "    QObject::connect(" + stateLower + "State, &QState::entered, []() {\n";
            code += "        debugPrint(DOUBLE_SEPARATOR);\n";
            code += "        debugPrint(STATE_HEADER + ANSI_BOLD + COLOR_STATE + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "        debugPrint(\"Executing onEntry action for state: \" + ANSI_BOLD + \"" + stateName + "\" + ANSI_RESET);\n";
            code += "        " + onEntry + "\n";
            code += "        // Clear trigger inputs after they've been processed\n";
            code += "        clearTriggerInputs();\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "    });\n";
        } else {
            // Even if no onEntry code, still provide visual feedback and clear triggers
            code += "    QObject::connect(" + stateLower + "State, &QState::entered, []() {\n";
            code += "        debugPrint(DOUBLE_SEPARATOR);\n";
            code += "        debugPrint(STATE_HEADER + ANSI_BOLD + COLOR_STATE + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
            code += "        // Clear trigger inputs even if no actions are performed\n";
            code += "        clearTriggerInputs();\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "    });\n";
        }
        code += "\n";
    }
    
    // Set initial state
    code += "    // Set initial state\n";
    code += "    fsm.setInitialState(" + initialStateName.toLower() + "State);\n";
    code += "    debugPrint(\"Initial state set to \" + ANSI_BOLD + COLOR_TARGET + \"" + initialStateName + "\" + ANSI_RESET);\n\n";
    
    // Create transitions between states
    code += "    // Create transitions between states\n";
    code += "    debugPrint(\"Setting up transitions...\");\n";
    
    // Iterate through all states and their transitions
    for (auto stateIt = allStates.begin(); stateIt != allStates.end(); ++stateIt) {
        State* sourceState = stateIt.value();
        QString sourceName = sourceState->getName();
        
        // Get all transitions from this state
        QList<Transition*> transitions = fsm->getTransitionsFrom(sourceState);
        
        for (Transition* transition : transitions) {
            State* targetState = transition->getTo();
            if (!targetState) continue;
            
            QString targetName = targetState->getName();
            
            // Display the transition info with condition and/or delay
            code += "    // Create transition: " + sourceName + " → " + targetName;
            
            QString condition = transition->getCondition();
            bool hasDelay = transition->isDelayedTransition();
            
            if (!condition.isEmpty() || hasDelay) {
                code += " (";
                if (!condition.isEmpty()) {
                    code += "[ " + condition + " ]";
                }
                if (hasDelay) {
                    if (!condition.isEmpty()) code += " ";
                    code += "@ " + QString::number(transition->getDelay());
                }
                code += ")";
            }
            
            code += "\n";
            
            // Generate the transition code
            code += generateTransitionCode(transition, sourceState, targetState);
        }
    }
    
    // Use the showHelp function at application startup
    code += "    // Print application usage help\n";
    code += "    showHelp(validInputNames, helpLines);\n";
    code += "    qDebug().noquote() << \"\";\n\n";

    // Add terminal input setup
    code += "    // Setup input handling from the terminal\n";
    code += "    FILE* terminalInput = fdopen(dup(STDIN_FILENO), \"r\");\n";
    code += "    if (!terminalInput) {\n";
    code += "        debugPrint(\"Error: Could not open terminal input\", 3);\n";
    code += "        return 1;\n";
    code += "    }\n\n";
    
    // Create a notifier for terminal input
    code += "    // Create a notifier for terminal input\n";
    code += "    int terminalFd = fileno(terminalInput);\n";
    code += "    QSocketNotifier* inputNotifier = new QSocketNotifier(terminalFd, QSocketNotifier::Read);\n\n";
    
    // Updated input handler with input validation
    code += "    QObject::connect(inputNotifier, &QSocketNotifier::activated, [&]() {\n";
    code += "        // Read from the terminal\n";
    code += "        char buffer[1024];\n";
    code += "        if (fgets(buffer, sizeof(buffer), terminalInput)) {\n";
    code += "            QString line = QString::fromUtf8(buffer).trimmed();\n";
    code += "            \n";
    code += "            if (line.isEmpty()) {\n";
    code += "                inputNotifier->setEnabled(true);\n";
    code += "                return;\n";
    code += "            }\n";
    code += "            \n";
    code += "            // Get current state for context\n";
    code += "            QString currentState = fsm.configuration().isEmpty() ? \"UNKNOWN\" : \n";
    code += "                                  (*fsm.configuration().begin())->objectName();\n";
    code += "            \n";
    code += "            // Show command header for any input\n";
    code += "            qDebug().noquote() << \"\\n\" + COMMAND_HEADER + line;\n";
    code += "            \n";
    code += "            if (line.contains('=')) {\n";
    code += "                // Process input with explicit value (name=value format)\n";
    code += "                int pos = line.indexOf('=');\n";
    code += "                QString name = line.left(pos);\n";
    code += "                QString value = line.mid(pos + 1);\n";
    code += "                \n";
    code += "                // Validate input name\n";
    code += "                if (!validInputNames.contains(name)) {\n";
    code += "                    debugPrint(\"Unknown input: '\" + ANSI_BOLD + name + ANSI_RESET + \"'. Valid inputs are: \" + \n";
    code += "                               validInputNames.values().join(\", \"), 2);\n";
    code += "                    inputNotifier->setEnabled(true);\n";
    code += "                    return;\n";
    code += "                }\n";
    code += "                \n";
    code += "                // Single consolidated message for input handling\n";
    code += "                debugPrint(\"Received input in state \" + COSMIC_PURPLE + currentState + ANSI_RESET + \": \" + \n";
    code += "                          ANSI_BOLD + name + ANSI_RESET + \" = \" + STARDUST + value + ANSI_RESET);\n";
    code += "                \n";
    code += "                inputs[name] = value;\n";
    code += "                fsm.postEvent(new InputEvent(name, value));\n";
    code += "            } else if (line == \"exit\" || line == \"quit\") {\n";
    code += "                debugPrint(ANSI_BOLD + COLOR_ERROR + \"Exit command received. Terminating application...\" + ANSI_RESET);\n";
    code += "                app.quit();\n";
    code += "            } else if (line == \"status\") {\n";
    code += "                // Enhanced status display with bullet points and consistent formatting\n";
    code += "                qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "                qDebug().noquote() << \"[\" << timeMs << \"]\" << ANSI_BOLD + COLOR_INFO + \"SYSTEM STATUS\" + ANSI_RESET;\n";
    code += "                qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "                \n";
    code += "                // Current state - always shown\n";
    code += "                qDebug().noquote() << \"• Current state: \" + ANSI_BOLD + COSMIC_PURPLE + currentState + ANSI_RESET;\n";
    code += "                \n";
    code += "                // Print inputs with bullet points\n";
    code += "                if (!inputs.isEmpty()) {\n";
    code += "                    qDebug().noquote() << \"\\n• Input values:\";\n";
    code += "                    for (auto it = inputs.constBegin(); it != inputs.constEnd(); ++it) {\n";
    code += "                        qDebug().noquote() << \"  \" + SYM_BULLET_2 + \" \" + COLOR_INPUT + it.key() + ANSI_RESET + \" = \" + \n";
    code += "                                        (it.value().isEmpty() ? COLOR_NOTICE + \"<empty>\" + ANSI_RESET : COLOR_VALUE + it.value() + ANSI_RESET);\n";
    code += "                    }\n";
    code += "                }\n";
    code += "                \n";
    code += "                // Print outputs with bullet points\n";
    code += "                if (!outputs.isEmpty()) {\n";
    code += "                    qDebug().noquote() << \"\\n• Output values:\";\n";
    code += "                    for (auto it = outputs.constBegin(); it != outputs.constEnd(); ++it) {\n";
    code += "                        qDebug().noquote() << \"  \" + SYM_BULLET_2 + \" \" + COLOR_OUTPUT + it.key() + ANSI_RESET + \" = \" + \n";
    code += "                                        (it.value().isEmpty() ? COLOR_NOTICE + \"<empty>\" + ANSI_RESET : COLOR_VALUE + it.value() + ANSI_RESET);\n";
    code += "                    }\n";
    code += "                }\n";
    code += "                qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "            } else if (line == \"help\") {\n";
    code += "                // Show help using the dedicated function\n";
    code += "                showHelp(validInputNames, helpLines);\n";
    code += "            } else {\n";
    code += "                // Treat the entire line as a standalone input event\n";
    code += "                QString name = line;\n";
    code += "                QString defaultValue = \"true\";\n";
    code += "                \n";
    code += "                // Validate input name\n";
    code += "                if (!validInputNames.contains(name)) {\n";
    code += "                    debugPrint(\"Unknown input: '\" + ANSI_BOLD + name + ANSI_RESET + \"'. Valid inputs are: \" + \n";
    code += "                               validInputNames.values().join(\", \"), 2);\n";
    code += "                    inputNotifier->setEnabled(true);\n";
    code += "                    return;\n";
    code += "                }\n";
    code += "                \n";
    code += "                debugPrint(\"Received standalone input in state \" + COSMIC_PURPLE + currentState + ANSI_RESET + \": \" + \n";
    code += "                          ANSI_BOLD + name + ANSI_RESET + \" (default value: \" + STARDUST + defaultValue + ANSI_RESET + \")\");\n";
    code += "                \n";
    code += "                inputs[name] = defaultValue;\n";
    code += "                fsm.postEvent(new InputEvent(name, defaultValue));\n";
    code += "            }\n";
    code += "        }\n";
    code += "        \n";
    code += "        // Re-enable the notifier\n";
    code += "        inputNotifier->setEnabled(true);\n";
    code += "    });\n\n";

    code += "    debugPrint(ANSI_BOLD + COLOR_HEADER + \"INITIALIZING STATE MACHINE\" + ANSI_RESET);\n";
    code += "    fsm.start();\n";
    code += "    debugPrint(COLOR_SUCCESS + SYM_SUCCESS + \" Transition engine activated successfully\" + ANSI_RESET);\n";
    code += "    qDebug().noquote() << \"\"; // Empty line for better readability\n\n";
    code += "    // Run the application\n";
    code += "    int result = app.exec();\n";
    code += "    debugPrint(\"Application terminated with code \" + QString::number(result));\n";
    code += "    return result;\n";
    code += "}\n";
    
    return code;
}
