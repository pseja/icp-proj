#include "CodeGen.hpp"
#include <QFinalState>
#include <QDebug>

/**
 * @brief Constructor for the CodeGen class
 * @param parent The parent QObject
 */
CodeGen::CodeGen(QObject *parent) : QObject(parent)
{
}

/**
 * @brief Generates complete C++ code from a state machine
 * 
 * This is the main entry point for code generation. It orchestrates the 
 * generation process by calling the specialized generation methods for
 * different parts of the code.
 * 
 * @param machine The state machine to generate code from
 * @return Generated C++ code as a QString
 */
QString CodeGen::generateCode(QStateMachine *machine)
{
    QString code;

    // Generate file header with automaton info
    code += "/**\n";
    code += " * Generated Finite State Machine: " + machine->objectName() + "\n";
    
    // Add description if available
    QString description = machine->property("description").toString();
    if (!description.isEmpty()) {
        code += " * Description: " + description + "\n";
    }
    
    code += " * \n";
    code += " * This file was automatically generated by ICP FSM Code Generator\n";
    code += " */\n\n";

    // Generate the various code sections
    code += generateHeaders();
    code += generateVariableDeclarations(machine);
    code += generateRuntimeMonitoring();

    // Get the flat list of states from the machine (excluding QFinalState)
    QList<QState*> realStates;
    for (QState* state : machine->findChildren<QState*>()) {
        if (!qobject_cast<QFinalState*>(state)) {
            realStates.append(state);
        }
    }
    
    code += generateHelperFunctions();
    code += generateQStateMachineMain(machine, realStates);

    return code;
}
/**
 * @brief Generates standard C++ header includes
 * 
 * Creates the include statements needed for the generated code, 
 * focusing on Qt libraries for platform independence.
 * 
 * @return Code section as QString
 */
QString CodeGen::generateHeaders()
{
    QString code;
    
    // Use Qt libraries for platform independence
    code += "#include <QtCore/QDebug>\n";
    code += "#include <QtCore/QString>\n";
    code += "#include <QtCore/QMap>\n";
    code += "#include <QtCore/QDateTime>\n";
    code += "#include <QtCore/QCoreApplication>\n";
    code += "#include <QtCore/QTimer>\n";
    code += "#include <QtCore/QSocketNotifier>\n";
    code += "#include <QtCore/QStateMachine>\n";
    code += "#include <QtCore/QState>\n";
    code += "#include <QtCore/QEvent>\n";
    code += "#include <QtCore/QAbstractTransition>\n";
    code += "#include <stdio.h>\n";
    code += "#include <unistd.h>\n";
    code += "\n";
    
    return code;
}

/**
 * @brief Generates helper functions for FSM operations
 * 
 * Creates utility functions that assist with state machine operations,
 * such as input value retrieval, type conversion, and output generation.
 * 
 * @return Code section as QString
 */
QString CodeGen::generateHelperFunctions()
{
    QString code;
    
    code += "/******************************************************************************\n";
    code += " * Helper functions for FSM operations\n";
    code += " ******************************************************************************/\n\n";
    
    // Gets the string value of an input
    code += "/**\n";
    code += " * @brief Gets the string value of an input\n";
    code += " * @param input Input name\n";
    code += " * @return Current string value of the input, or empty string if not found\n";
    code += " */\n";
    code += "QString valueof(const QString &input) {\n";
    code += "    if (inputs.contains(input)) {\n";
    code += "        return inputs[input];\n";
    code += "    }\n";
    code += "    return QString();\n";
    code += "}\n\n";
    
    // Convert string to int safely
    code += "/**\n";
    code += " * @brief Safely converts a string to an integer\n";
    code += " * @param str String to convert\n";
    code += " * @return Integer value, or 0 if conversion fails\n";
    code += " */\n";
    code += "int atoi_safe(const QString &str) {\n";
    code += "    bool ok = false;\n";
    code += "    int value = str.toInt(&ok);\n";
    code += "    return ok ? value : 0;\n";
    code += "}\n\n";
    
    // Check if input exists and has value
    code += "/**\n";
    code += " * @brief Checks if an input is defined and has a non-empty value\n";
    code += " * @param input Input name to check\n";
    code += " * @return True if the input exists and has a value\n";
    code += " */\n";
    code += "bool defined(const QString &input) {\n";
    code += "    return inputs.contains(input) && !inputs[input].isEmpty();\n";
    code += "}\n\n";
    
    // Output function
    code += "/**\n";
    code += " * @brief Sends an output value to a specific port\n";
    code += " * @param port Output port name\n";
    code += " * @param value Integer value to send\n";
    code += " */\n";
    code += "void output(const QString &port, int value) {\n";
    code += "    outputs[port] = QString::number(value);\n";
    code += "    logOutputEvent(port, QString::number(value));\n";
    code += "}\n\n";
    
    return code;
}

/**
 * @brief Generates global variable declarations
 * 
 * Creates declarations for core state machine variables and any custom
 * variables defined in the state machine properties.
 * 
 * @param machine State machine containing property definitions
 * @return Code section as QString
 */
QString CodeGen::generateVariableDeclarations(QStateMachine *machine)
{
    QString code;
    
    code += "/******************************************************************************\n";
    code += " * Variable declarations\n";
    code += " ******************************************************************************/\n\n";
    
    // Core state machine variables
    code += "QMap<QString, QString> inputs;      // Map of input names to values\n";
    code += "QMap<QString, QString> outputs;     // Map of output names to values\n\n";
    
    // Extract custom variables from machine properties
    QVariant vars = machine->property("variables");
    if (vars.isValid() && vars.canConvert<QString>()) {
        code += "// Custom variables for " + machine->objectName() + "\n";
        code += vars.toString() + "\n\n";
    }
    
    return code;
}

/**
 * @brief Generates monitoring and debugging functions
 * 
 * Creates functions for runtime monitoring of the state machine,
 * including state transitions, input/output events, and general
 * debugging utilities.
 * 
 * @return Code section as QString
 */
QString CodeGen::generateRuntimeMonitoring()
{
    QString code;
    
    // Add section header comment
    code += "/******************************************************************************\n";
    code += " * Runtime monitoring and debugging\n";
    code += " ******************************************************************************/\n\n";

    // Add ANSI color codes for terminal output
    code += "// ANSI color codes for terminal output\n";
    code += "const QString ANSI_RESET = \"\\033[0m\";\n";
    code += "const QString ANSI_BOLD = \"\\033[1m\";\n";
    code += "const QString ANSI_RED = \"\\033[31m\";\n";
    code += "const QString ANSI_GREEN = \"\\033[32m\";\n";
    code += "const QString ANSI_YELLOW = \"\\033[33m\";\n";
    code += "const QString ANSI_BLUE = \"\\033[34m\";\n";
    code += "const QString ANSI_MAGENTA = \"\\033[35m\";\n";
    code += "const QString ANSI_CYAN = \"\\033[36m\";\n";
    code += "const QString ANSI_WHITE = \"\\033[37m\";\n\n";

    // State change logging function
    code += "/**\n";
    code += " * @brief Logs state transitions for monitoring\n";
    code += " * @param fromState Source state name\n";
    code += " * @param toState Target state name\n";
    code += " */\n";
    code += "void logStateChange(const QString& fromState, const QString& toState) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" \n";
    code += "             << ANSI_BOLD + ANSI_MAGENTA + \"STATE CHANGE:\" + ANSI_RESET\n";
    code += "             << ANSI_CYAN + fromState + ANSI_RESET << \"->\"\n";
    code += "             << ANSI_GREEN + ANSI_BOLD + toState + ANSI_RESET;\n";
    code += "}\n\n";
    
    // Input event logging function
    code += "/**\n";
    code += " * @brief Logs input values for monitoring\n";
    code += " * @param input Input name\n";
    code += " * @param value Input value\n";
    code += " */\n";
    code += "void logInputEvent(const QString& input, const QString& value) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\"\n";
    code += "             << ANSI_YELLOW + \"INPUT:\" + ANSI_RESET\n";
    code += "             << ANSI_BOLD + input + ANSI_RESET << \"=\"\n";
    code += "             << ANSI_CYAN + value + ANSI_RESET;\n";
    code += "}\n\n";
    
    // Output event logging function
    code += "/**\n";
    code += " * @brief Logs output values for monitoring\n";
    code += " * @param output Output name\n";
    code += " * @param value Output value\n";
    code += " */\n";
    code += "void logOutputEvent(const QString& output, const QString& value) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\"\n";
    code += "             << ANSI_GREEN + \"OUTPUT:\" + ANSI_RESET\n";
    code += "             << ANSI_BOLD + output + ANSI_RESET << \"=\"\n";
    code += "             << ANSI_CYAN + value + ANSI_RESET;\n";
    code += "}\n\n";
    
    // Debug print function for general debugging messages
    code += "/**\n";
    code += " * @brief Prints a debug message with timestamp\n";
    code += " * @param message Debug message to display\n";
    code += " * @param level Debug level (0=INFO, 1=NOTICE, 2=WARNING, 3=ERROR)\n";
    code += " */\n";
    code += "void debugPrint(const QString& message, int level = 0) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    QString prefix;\n";
    code += "    switch (level) {\n";
    code += "        case 0: prefix = ANSI_BLUE + \"INFO:\" + ANSI_RESET; break;\n";
    code += "        case 1: prefix = ANSI_CYAN + \"NOTICE:\" + ANSI_RESET; break;\n";
    code += "        case 2: prefix = ANSI_YELLOW + \"WARNING:\" + ANSI_RESET; break;\n";
    code += "        case 3: prefix = ANSI_RED + \"ERROR:\" + ANSI_RESET; break;\n";
    code += "        default: prefix = \"DEBUG:\";\n";
    code += "    }\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" << prefix << message;\n";
    code += "}\n\n";

    return code;
}

/**
 * @brief Generates a main function that uses QStateMachine
 * 
 * Creates the main function that uses Qt's built-in QStateMachine rather
 * than a manual switch-case approach. This leverages Qt's state machine framework
 * for cleaner code and better integration with Qt's event system.
 * 
 * @param machine State machine containing the initial state
 * @param states List of all states in the machine
 * @return Code section as QString
 */
QString CodeGen::generateQStateMachineMain(QStateMachine *machine, const QList<QState*>& states)
{
    QString code;
    
    // Add section header comment
    code += "/******************************************************************************\n";
    code += " * Main function with QStateMachine\n";
    code += " ******************************************************************************/\n\n";

    // Get the initial state
    QState *initial = qobject_cast<QState*>(machine->initialState());
    if (!initial && !states.isEmpty()) {
        initial = states.first();
    }
    QString initialStateName = initial ? initial->objectName() : "UNKNOWN";

    // Add custom color constants for enhanced formatting
    code += "// Enhanced UI formatting constants\n";
    code += "const QString STATE_HEADER = ANSI_BOLD + ANSI_BLUE + \"════════ STATE: \" + ANSI_RESET;\n";
    code += "const QString COMMAND_HEADER = ANSI_BOLD + ANSI_CYAN + \"⟫ COMMAND: \" + ANSI_RESET;\n";
    code += "const QString SECTION_SEPARATOR = ANSI_CYAN + \"───────────────────────────────────────────────────\" + ANSI_RESET;\n";
    code += "const QString DOUBLE_SEPARATOR = ANSI_YELLOW + \"═══════════════════════════════════════════════════\" + ANSI_RESET;\n\n";

    // Define the classes needed for QStateMachine
    code += "/**\n";
    code += " * @brief Custom transition that evaluates a condition expression\n";
    code += " */\n";
    code += "class ConditionTransition : public QAbstractTransition {\n";
    code += "public:\n";
    code += "    ConditionTransition(const QString& condition) : m_condition(condition) {}\n\n";
    
    code += "protected:\n";
    code += "    bool eventTest(QEvent* event) override {\n";
    code += "        Q_UNUSED(event);\n";
    code += "        // Evaluate the condition code\n";
    code += "        if (m_condition.isEmpty()) return false;\n";
    code += "        \n";
    code += "        // The condition code is expected to use functions like defined(), valueof(), atoi_safe()\n";
    code += "        // which we've defined in our helper functions\n";
    code += "        bool result = false;\n";
    code += "        try {\n";
    code += "            // We're evaluating a C++ expression in runtime\n";
    code += "            // In a real implementation, you'd need to implement an expression evaluator\n";
    code += "            // or use lambdas. For simplicity, we're doing a direct check here\n";
    code += "            result = eval(m_condition);\n";
    code += "        } catch (...) {\n";
    code += "            debugPrint(\"Error evaluating condition: \" + m_condition, 3);\n";
    code += "            return false;\n";
    code += "        }\n";
    code += "        return result;\n";
    code += "    }\n\n";
    
    // Enhance the onTransition method in ConditionTransition class
    code += "    void onTransition(QEvent* event) override {\n";
    code += "        Q_UNUSED(event);\n";
    code += "        debugPrint(SECTION_SEPARATOR);\n";
    code += "        debugPrint(ANSI_BOLD + ANSI_YELLOW + \"CONDITION TRIGGERED: \" + ANSI_RESET + m_condition);\n";
    code += "        debugPrint(SECTION_SEPARATOR);\n";
    code += "    }\n\n";
    
    code += "    bool eval(const QString& condition) {\n";
    code += "        // In a real implementation, you'd use a proper expression evaluator\n";
    code += "        // This is a simplistic approach for demonstration\n";
    code += "        if (condition.contains(\"defined(\\\"in\\\") && atoi_safe(valueof(\\\"in\\\")) == 1\")) {\n";
    code += "            return defined(\"in\") && atoi_safe(valueof(\"in\")) == 1;\n";
    code += "        }\n";
    code += "        else if (condition.contains(\"defined(\\\"in\\\") && atoi_safe(valueof(\\\"in\\\")) == 0\")) {\n";
    code += "            return defined(\"in\") && atoi_safe(valueof(\"in\")) == 0;\n";
    code += "        }\n";
    code += "        debugPrint(\"Unknown condition: \" + condition, 2);\n";
    code += "        return false;\n";
    code += "    }\n\n";
    
    code += "private:\n";
    code += "    QString m_condition;\n";
    code += "};\n\n";

    code += "/**\n";
    code += " * @brief Class for handling timer-based transitions using Qt's timer system\n";
    code += " */\n";
    code += "class DelayedStateTransition : public QAbstractTransition {\n";
    code += "public:\n";
    code += "    DelayedStateTransition(int delayMs) : m_delay(delayMs), m_timer(new QTimer(this)) {\n";
    code += "        m_timer->setSingleShot(true);\n";
    code += "        connect(m_timer, &QTimer::timeout, this, &DelayedStateTransition::timeout);\n";
    code += "    }\n\n";
    
    code += "    void start() {\n";
    code += "        m_timer->start(m_delay);\n";
    code += "        debugPrint(\"Started delayed transition timer for \" + QString::number(m_delay) + \"ms\");\n";
    code += "        // Show expected completion time\n";
    code += "        QDateTime expectedCompletion = QDateTime::currentDateTime().addMSecs(m_delay);\n";
    code += "        debugPrint(ANSI_BOLD + \"TIMER:\" + ANSI_RESET + \" Will expire at \" + \n";
    code += "                  ANSI_YELLOW + expectedCompletion.toString(\"hh:mm:ss.zzz\") + ANSI_RESET + \n";
    code += "                  \" (in \" + QString::number(m_delay) + \"ms)\");\n";
    code += "    }\n\n";
    
    code += "protected:\n";
    code += "    bool eventTest(QEvent* event) override {\n";
    code += "        // This only triggers on our custom timeout event\n";
    code += "        return event->type() == QEvent::User + 1;\n";
    code += "    }\n\n";
    
    code += "    void onTransition(QEvent* event) override {\n";
    code += "        Q_UNUSED(event);\n";
    code += "        debugPrint(DOUBLE_SEPARATOR);\n";
    code += "        debugPrint(ANSI_BOLD + ANSI_RED + \"TIMER EXPIRED: \" + ANSI_RESET + \"Delayed transition triggered after \" + \n";
    code += "                  ANSI_BOLD + QString::number(m_delay) + \"ms\" + ANSI_RESET);\n";
    code += "        debugPrint(DOUBLE_SEPARATOR);\n";
    code += "    }\n\n";
    
    code += "private slots:\n";
    code += "    void timeout() {\n";
    code += "        // Create a custom event to trigger the transition\n";
    code += "        QEvent* event = new QEvent(static_cast<QEvent::Type>(QEvent::User + 1));\n";
    code += "        machine()->postEvent(event);\n";
    code += "    }\n\n";
    
    code += "private:\n";
    code += "    int m_delay;\n";
    code += "    QTimer* m_timer;\n";
    code += "};\n\n";

    code += "/**\n";
    code += " * @brief Custom event for input changes\n";
    code += " */\n";
    code += "class InputEvent : public QEvent {\n";
    code += "public:\n";
    code += "    static const QEvent::Type InputChangedType = static_cast<QEvent::Type>(QEvent::User + 2);\n\n";
    
    code += "    InputEvent(const QString& name, const QString& value) \n";
    code += "        : QEvent(InputChangedType), m_name(name), m_value(value) {}\n\n";
    
    code += "    QString name() const { return m_name; }\n";
    code += "    QString value() const { return m_value; }\n\n";
    
    code += "private:\n";
    code += "    QString m_name;\n";
    code += "    QString m_value;\n";
    code += "};\n\n";

    code += "/**\n";
    code += " * @brief Main function that uses QStateMachine for state management\n";
    code += " */\n";
    code += "int main(int argc, char *argv[]) {\n";
    code += "    QCoreApplication app(argc, argv);\n";
    code += "    \n";
    code += "    // Application header with visual emphasis\n";
    code += "    qDebug().noquote() << \"\\n\" + DOUBLE_SEPARATOR;\n";
    code += "    qDebug().noquote() << ANSI_BOLD + ANSI_GREEN + \"◆ ◆ ◆  QT STATE MACHINE APPLICATION  ◆ ◆ ◆\" + ANSI_RESET;\n";
    code += "    qDebug().noquote() << DOUBLE_SEPARATOR + \"\\n\";\n";
    code += "    \n";
    code += "    debugPrint(\"Starting FSM application with QStateMachine\");\n";
    code += "    debugPrint(\"State machine name: \" + ANSI_BOLD + ANSI_GREEN + \"" + machine->objectName() + "\" + ANSI_RESET);\n";
    
    // Extract and initialize inputs/outputs
    QStringList inputNames = machine->property("inputs").toString().split(",", Qt::SkipEmptyParts);
    QStringList outputNames = machine->property("outputs").toString().split(",", Qt::SkipEmptyParts);
    
    code += "    // Initialize inputs and outputs\n";
    for (const QString& input : inputNames) {
        code += "    inputs[QStringLiteral(\"" + input.trimmed() + "\")] = QString();\n";
    }
    
    for (const QString& output : outputNames) {
        code += "    outputs[QStringLiteral(\"" + output.trimmed() + "\")] = QString();\n";
    }
    code += "\n";
    
    // Create the state machine object
    code += "    // Create state machine\n";
    code += "    QStateMachine fsm;\n";
    code += "    fsm.setObjectName(\"" + machine->objectName() + "\");\n\n";
    
    // Enhanced state creation display
    code += "    // Create all states\n";
    code += "    debugPrint(\"Creating states...\");\n";
    for (QState* state : states) {
        QString stateName = state->objectName();
        code += "    QState* " + stateName.toLower() + "State = new QState(&fsm);\n";
        code += "    " + stateName.toLower() + "State->setObjectName(\"" + stateName + "\");\n";
        code += "    debugPrint(\"  Created state: \" + ANSI_CYAN + \"" + stateName + "\" + ANSI_RESET);\n";
        
        // Add onEntry code if available
        QString onEntry = state->property("on_entry_code").toString();
        if (!onEntry.isEmpty()) {
            code += "    QObject::connect(" + stateName.toLower() + "State, &QState::entered, []() {\n";
            code += "        debugPrint(DOUBLE_SEPARATOR);\n";
            code += "        debugPrint(STATE_HEADER + ANSI_BOLD + ANSI_GREEN + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "        debugPrint(\"Executing onEntry action for state: \" + ANSI_BOLD + \"" + stateName + "\" + ANSI_RESET);\n";
            code += "        " + onEntry + "\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "    });\n";
        } else {
            // Even if no onEntry code, still provide visual feedback for state entry
            code += "    QObject::connect(" + stateName.toLower() + "State, &QState::entered, []() {\n";
            code += "        debugPrint(DOUBLE_SEPARATOR);\n";
            code += "        debugPrint(STATE_HEADER + ANSI_BOLD + ANSI_GREEN + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "    });\n";
        }
        code += "\n";
    }
    
    // Set initial state
    code += "    // Set initial state\n";
    code += "    fsm.setInitialState(" + initialStateName.toLower() + "State);\n";
    code += "    debugPrint(\"Initial state set to \" + ANSI_BOLD + ANSI_GREEN + \"" + initialStateName + "\" + ANSI_RESET);\n\n";
    
    // Create transitions between states
    code += "    // Create transitions between states\n";
    code += "    debugPrint(\"Setting up transitions...\");\n";
    for (QState* sourceState : states) {
        QString sourceName = sourceState->objectName();
        QList<QAbstractTransition*> transitions = sourceState->transitions();
        
        for (QAbstractTransition* transition : transitions) {
            QState* targetState = qobject_cast<QState*>(transition->targetState());
            if (!targetState) continue;
            
            QString targetName = targetState->objectName();
            bool isDelayed = transition->property("is_delayed_transition").toBool();
            
            if (isDelayed) {
                // Create a delayed transition
                QString delayMs = transition->property("delay_ms").toString();
                code += "    // Create delayed transition: " + sourceName + " → " + targetName + "\n";
                code += "    DelayedStateTransition* " + sourceName.toLower() + "To" + targetName + "Delayed = new DelayedStateTransition(" + delayMs + ");\n";
                code += "    " + sourceName.toLower() + "State->addTransition(" + sourceName.toLower() + "To" + targetName + "Delayed);\n";
                code += "    " + sourceName.toLower() + "To" + targetName + "Delayed->setTargetState(" + targetName.toLower() + "State);\n";
                code += "    QObject::connect(" + sourceName.toLower() + "State, &QState::entered, [=]() {\n";
                code += "        " + sourceName.toLower() + "To" + targetName + "Delayed->start();\n";
                code += "    });\n\n";
            } else {
                // Create a condition-based transition
                QString condition = transition->property("condition_code").toString();
                if (!condition.isEmpty()) {
                    code += "    // Create condition transition: " + sourceName + " → " + targetName + "\n";
                    code += "    ConditionTransition* " + sourceName.toLower() + "To" + targetName + "Condition = new ConditionTransition(\"" + condition.replace("\"", "\\\"") + "\");\n";
                    code += "    " + sourceName.toLower() + "State->addTransition(" + sourceName.toLower() + "To" + targetName + "Condition);\n";
                    code += "    " + sourceName.toLower() + "To" + targetName + "Condition->setTargetState(" + targetName.toLower() + "State);\n\n";
                }
            }
        }
    }
    
    // Add an enhanced command prompt and help display
    code += "    // Print application usage help\n";
    code += "    qDebug().noquote() << \"\\n\" + DOUBLE_SEPARATOR;\n";
    code += "    qDebug().noquote() << ANSI_BOLD + ANSI_BLUE + \"          AVAILABLE COMMANDS          \" + ANSI_RESET;\n";
    code += "    qDebug().noquote() << DOUBLE_SEPARATOR;\n";
    code += "    qDebug().noquote() << ANSI_BOLD + \"name=value\" + ANSI_RESET + \" - Set an input value\";\n";
    code += "    qDebug().noquote() << ANSI_BOLD + \"status\" + ANSI_RESET + \"    - Show the current system state\";\n";
    code += "    qDebug().noquote() << ANSI_BOLD + \"help\" + ANSI_RESET + \"      - Show this help message\";\n";
    code += "    qDebug().noquote() << ANSI_BOLD + \"quit/exit\" + ANSI_RESET + \" - Exit the application\";\n";
    code += "    qDebug().noquote() << DOUBLE_SEPARATOR + \"\\n\";\n\n";

    // Enhanced input handling
    code += "    // Setup input handling from the terminal\n";
    code += "    FILE* terminalInput = fdopen(dup(STDIN_FILENO), \"r\");\n";
    code += "    if (!terminalInput) {\n";
    code += "        debugPrint(\"Error: Could not open terminal input\", 3);\n";
    code += "        return 1;\n";
    code += "    }\n\n";
    
    code += "    // Create a notifier for terminal input\n";
    code += "    int terminalFd = fileno(terminalInput);\n";
    code += "    QSocketNotifier* inputNotifier = new QSocketNotifier(terminalFd, QSocketNotifier::Read);\n";
    code += "    QObject::connect(inputNotifier, &QSocketNotifier::activated, [&]() {\n";
    code += "        // Read from the terminal\n";
    code += "        char buffer[1024];\n";
    code += "        if (fgets(buffer, sizeof(buffer), terminalInput)) {\n";
    code += "            QString line = QString::fromUtf8(buffer).trimmed();\n";
    code += "            \n";
    code += "            if (line.isEmpty()) {\n";
    code += "                // Re-enable the notifier and return\n";
    code += "                inputNotifier->setEnabled(true);\n";
    code += "                return;\n";
    code += "            }\n";
    code += "            \n";
    code += "            // Visual separator for commands\n";
    code += "            qDebug().noquote() << \"\\n\" + SECTION_SEPARATOR;\n";
    code += "            qDebug().noquote() << COMMAND_HEADER + ANSI_YELLOW + \"\\\"\" + line + \"\\\"\" + ANSI_RESET;\n";
    code += "            qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "            \n";
    code += "            if (line.contains('=')) {\n";
    code += "                int pos = line.indexOf('=');\n";
    code += "                QString name = line.left(pos);\n";
    code += "                QString value = line.mid(pos + 1);\n";
    code += "                \n";
    code += "                debugPrint(\"Processing input: \" + ANSI_BOLD + name + ANSI_RESET + \" = \" + \n";
    code += "                          ANSI_CYAN + value + ANSI_RESET);\n";
    code += "                inputs[name] = value;\n";
    code += "                logInputEvent(name, value);\n";
    code += "                \n";
    code += "                // Post input event to trigger transitions\n";
    code += "                fsm.postEvent(new InputEvent(name, value));\n";
    code += "            } else if (line == \"exit\" || line == \"quit\") {\n";
    code += "                debugPrint(ANSI_BOLD + ANSI_RED + \"Exit command received. Terminating application...\" + ANSI_RESET);\n";
    code += "                app.quit();\n";
    code += "            } else if (line == \"status\") {\n";
    code += "                // Enhanced status display\n";
    code += "                debugPrint(DOUBLE_SEPARATOR);\n";
    code += "                debugPrint(ANSI_BOLD + ANSI_BLUE + \"           SYSTEM STATUS           \" + ANSI_RESET);\n";
    code += "                debugPrint(DOUBLE_SEPARATOR);\n";
    code += "                \n";
    code += "                if (!fsm.configuration().isEmpty()) {\n";
    code += "                    QString currentState = (*fsm.configuration().begin())->objectName();\n";
    code += "                    debugPrint(\"Current state: \" + ANSI_BOLD + ANSI_GREEN + currentState + ANSI_RESET);\n";
    code += "                } else {\n";
    code += "                    debugPrint(\"No active state\");\n";
    code += "                }\n";
    code += "                \n";
    code += "                // Print inputs\n";
    code += "                if (!inputs.isEmpty()) {\n";
    code += "                    debugPrint(SECTION_SEPARATOR);\n";
    code += "                    debugPrint(ANSI_BOLD + \"INPUT VALUES:\" + ANSI_RESET);\n";
    code += "                    for (auto it = inputs.constBegin(); it != inputs.constEnd(); ++it) {\n";
    code += "                        debugPrint(\"  \" + ANSI_CYAN + it.key() + ANSI_RESET + \" = \" + \n";
    code += "                                 (it.value().isEmpty() ? ANSI_YELLOW + \"<empty>\" + ANSI_RESET : it.value()));\n";
    code += "                    }\n";
    code += "                }\n";
    code += "                \n";
    code += "                // Print outputs\n";
    code += "                if (!outputs.isEmpty()) {\n";
    code += "                    debugPrint(SECTION_SEPARATOR);\n";
    code += "                    debugPrint(ANSI_BOLD + \"OUTPUT VALUES:\" + ANSI_RESET);\n";
    code += "                    for (auto it = outputs.constBegin(); it != outputs.constEnd(); ++it) {\n";
    code += "                        debugPrint(\"  \" + ANSI_GREEN + it.key() + ANSI_RESET + \" = \" + \n";
    code += "                                 (it.value().isEmpty() ? ANSI_YELLOW + \"<empty>\" + ANSI_RESET : it.value()));\n";
    code += "                    }\n";
    code += "                }\n";
    code += "                debugPrint(DOUBLE_SEPARATOR);\n";
    code += "            } else if (line == \"help\") {\n";
    code += "                // Enhanced help display\n";
    code += "                qDebug().noquote() << \"\\n\" + DOUBLE_SEPARATOR;\n";
    code += "                qDebug().noquote() << ANSI_BOLD + ANSI_BLUE + \"          AVAILABLE COMMANDS          \" + ANSI_RESET;\n";
    code += "                qDebug().noquote() << DOUBLE_SEPARATOR;\n";
    code += "                qDebug().noquote() << ANSI_BOLD + \"name=value\" + ANSI_RESET + \" - Set an input value\";\n";
    code += "                qDebug().noquote() << ANSI_BOLD + \"status\" + ANSI_RESET + \"    - Show the current system state\";\n";
    code += "                qDebug().noquote() << ANSI_BOLD + \"help\" + ANSI_RESET + \"      - Show this help message\";\n";
    code += "                qDebug().noquote() << ANSI_BOLD + \"quit/exit\" + ANSI_RESET + \" - Exit the application\";\n";
    code += "                qDebug().noquote() << DOUBLE_SEPARATOR + \"\\n\";\n";
    code += "            } else {\n";
    code += "                debugPrint(ANSI_RED + \"Unknown command: \" + ANSI_BOLD + \"\\\"\" + line + \"\\\"\" + ANSI_RESET, 2);\n";
    code += "                debugPrint(\"Type 'help' to see available commands\");\n";
    code += "            }\n";
    code += "        }\n";
    code += "        \n";
    code += "        // Re-enable the notifier\n";
    code += "        inputNotifier->setEnabled(true);\n";
    code += "    });\n\n";
    
    // Start the state machine with enhanced output
    code += "    // Start the state machine\n";
    code += "    debugPrint(DOUBLE_SEPARATOR);\n";
    code += "    debugPrint(ANSI_BOLD + ANSI_GREEN + \"STARTING STATE MACHINE\" + ANSI_RESET);\n";
    code += "    fsm.start();\n";
    code += "    debugPrint(\"State machine started successfully\");\n";
    code += "    debugPrint(DOUBLE_SEPARATOR);\n";
    code += "    qDebug().noquote() << \"\"; // Empty line for better readability\n\n";
    
    code += "    // Run the application\n";
    code += "    int result = app.exec();\n";
    code += "    debugPrint(DOUBLE_SEPARATOR);\n";
    code += "    debugPrint(\"Application terminated with code \" + QString::number(result));\n";
    code += "    return result;\n";
    code += "}\n";
    
    return code;
}
