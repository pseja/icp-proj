#include "CodeGen.hpp"
#include "fsm.hpp"
#include "state.hpp"
#include "transition.hpp"
#include "variable.hpp"
#include <QDebug>
#include <QRegularExpression>
#include <csignal>

/**
 * @brief Constructor for the CodeGen class
 * @param parent The parent QObject
 */
CodeGen::CodeGen(QObject *parent) : QObject(parent)
{
}

/**
 * @brief Generates complete C++ code from a state machine
 * 
 * This is the main entry point for code generation. It orchestrates the 
 * generation process by calling the specialized generation methods for
 * different parts of the code.
 * 
 * @param fsm The state machine to generate code from
 * @return Generated C++ code as a QString
 */
QString CodeGen::generateCode(FSM *fsm)
{
    QString code;

    // Generate file header with automaton info
    code += "/**\n";
    code += " * Generated Finite State Machine: " + fsm->getName() + "\n";
    
    // Add description if available
    QString description = fsm->getComment();
    if (!description.isEmpty()) {
        code += " * Description: " + description + "\n";
    }
    
    code += " * \n";
    code += " * This file was automatically generated by ICP FSM Code Generator\n";
    code += " */\n\n";

    // Generate the various code sections
    code += generateHeaders();
    code += generateVariableDeclarations(fsm);
    code += generateRuntimeMonitoring();
    code += generateHelperFunctions();
    code += generateQStateMachineMain(fsm);

    return code;
}

/**
 * @brief Generates standard C++ header includes
 * 
 * Creates the include statements needed for the generated code, 
 * focusing on Qt libraries for platform independence.
 * 
 * @return Code section as QString
 */
QString CodeGen::generateHeaders()
{
    QString code;
    
    // Use Qt libraries for platform independence
    code += "#include <QtCore/QDebug>\n";
    code += "#include <QtCore/QString>\n";
    code += "#include <QtCore/QMap>\n";
    code += "#include <QtCore/QDateTime>\n";
    code += "#include <QtCore/QCoreApplication>\n";
    code += "#include <QtCore/QTimer>\n";
    code += "#include <QtCore/QSocketNotifier>\n";
    code += "#include <QtCore/QStateMachine>\n";
    code += "#include <QtCore/QState>\n";
    code += "#include <QtCore/QEvent>\n";
    code += "#include <QtCore/QAbstractTransition>\n";
    code += "#include <stdio.h>\n";
    code += "#include <unistd.h>\n";
    code += "#include <csignal>\n";
    code += "\n";
    
    return code;
}

/**
 * @brief Generates helper functions for FSM operations
 * 
 * Creates utility functions that assist with state machine operations,
 * such as input value retrieval, type conversion, and output generation.
 * 
 * @return Code section as QString
 */
QString CodeGen::generateHelperFunctions()
{
    QString code;
    
    code += "/******************************************************************************\n";
    code += " * Helper functions for FSM operations\n";
    code += " ******************************************************************************/\n\n";
    
    // Gets the string value of an input
    code += "/**\n";
    code += " * @brief Gets the string value of an input\n";
    code += " * @param input Input name\n";
    code += " * @return Current string value of the input, or empty string if not found\n";
    code += " */\n";
    code += "QString valueof(const QString &input) {\n";
    code += "    if (inputs.contains(input)) {\n";
    code += "        return inputs[input];\n";
    code += "    }\n";
    code += "    return QString();\n";
    code += "}\n\n";
    
    // Convert string to int safely
    code += "/**\n";
    code += " * @brief Safely converts a string to an integer\n";
    code += " * @param str String to convert\n";
    code += " * @return Integer value, or 0 if conversion fails\n";
    code += " */\n";
    code += "int atoi_safe(const QString &str) {\n";
    code += "    bool ok = false;\n";
    code += "    int value = str.toInt(&ok);\n";
    code += "    return ok ? value : 0;\n";
    code += "}\n\n";
    
    // Check if input exists and has value
    code += "/**\n";
    code += " * @brief Checks if an input is defined and has a non-empty value\n";
    code += " * @param input Input name to check\n";
    code += " * @return True if the input exists and has a value\n";
    code += " */\n";
    code += "bool defined(const QString &input) {\n";
    code += "    return inputs.contains(input) && !inputs[input].isEmpty();\n";
    code += "}\n\n";
    
    // Output function
    code += "/**\n";
    code += " * @brief Sends an output value to a specific port\n";
    code += " * @param port Output port name\n";
    code += " * @param value Integer value to send\n";
    code += " */\n";
    code += "void output(const QString &port, int value) {\n";
    code += "    outputs[port] = QString::number(value);\n";
    code += "    logOutputEvent(port, QString::number(value));\n";
    code += "}\n\n";
    
    return code;
}

/**
 * @brief Generates global variable declarations
 * 
 * Creates declarations for core state machine variables and any custom
 * variables defined in the state machine.
 * 
 * @param fsm State machine containing variable definitions
 * @return Code section as QString
 */
QString CodeGen::generateVariableDeclarations(FSM *fsm)
{
    QString code;
    
    code += "/******************************************************************************\n";
    code += " * Variable declarations\n";
    code += " ******************************************************************************/\n\n";
    
    // Core state machine variables
    code += "QMap<QString, QString> inputs;      // Map of input names to values\n";
    code += "QMap<QString, QString> outputs;     // Map of output names to values\n\n";
    
    // Extract custom variables from FSM
    QMap<QString, Variable*> variables = fsm->getVariables();
    if (!variables.isEmpty()) {
        code += "// Custom variables for " + fsm->getName() + "\n";
        
        for (auto it = variables.constBegin(); it != variables.constEnd(); ++it) {
            Variable* var = it.value();
            code += var->getType() + " " + var->getName() + " = " + var->getValue().toString() + ";\n";
        }
        code += "\n";
    }
    
    return code;
}

/**
 * @brief Generates monitoring and debugging functions
 * 
 * Creates functions for runtime monitoring of the state machine,
 * including state transitions, input/output events, and general
 * debugging utilities.
 * 
 * @return Code section as QString
 */
QString CodeGen::generateRuntimeMonitoring()
{
    QString code;
    
    // Add section header comment
    code += "/******************************************************************************\n";
    code += " * Runtime monitoring and debugging\n";
    code += " ******************************************************************************/\n\n";

    code += "// ANSI color codes for cosmic void / Oblivion theme\n";
    code += "const QString ANSI_RESET = \"\\033[0m\";\n";
    code += "const QString ANSI_BOLD = \"\\033[1m\";\n";
    code += "const QString ANSI_MAGENTA = \"\\033[95m\";          // Error/Warning (cool magenta)\n";
    code += "const QString ANSI_VOID_PURPLE = \"\\033[38;5;99m\"; // Deep Void Purple (accent color)\n";
    code += "const QString ANSI_OBLIVION_BLUE = \"\\033[96m\";    // Oblivion Blue (primary color)\n";
    code += "const QString ANSI_SILVER = \"\\033[37m\";           // Silver Mist (secondary color)\n";
    code += "const QString ANSI_CELESTIAL_WHITE = \"\\033[97m\";  // Celestial White (actions)\n";
    
    code += "const QString ANSI_RED = ANSI_MAGENTA;      // Errors\n";
    code += "const QString ANSI_GREEN = ANSI_VOID_PURPLE; // Success\n";
    code += "const QString ANSI_YELLOW = ANSI_OBLIVION_BLUE; // Warnings/Notice\n";
    code += "const QString ANSI_BLUE = ANSI_OBLIVION_BLUE;  // Info\n";
    code += "const QString ANSI_CYAN = ANSI_SILVER;       // Faded text\n";
    code += "const QString ANSI_WHITE = ANSI_CELESTIAL_WHITE; // Brightest text\n\n";

    code += "const QString STATE_HEADER = ANSI_BOLD + ANSI_VOID_PURPLE + \"════════ STATE: \" + ANSI_RESET;\n";
    code += "const QString COMMAND_HEADER = ANSI_BOLD + ANSI_CELESTIAL_WHITE + \"⟫ COMMAND: \" + ANSI_RESET;\n";
    code += "const QString SECTION_SEPARATOR = ANSI_SILVER + \"───────────────────────────────────────────────────\" + ANSI_RESET;\n";
    code += "const QString DOUBLE_SEPARATOR = ANSI_OBLIVION_BLUE + \"═══════════════════════════════════════════════════\" + ANSI_RESET;\n\n";

    // State change logging function
    code += "/**\n";
    code += " * @brief Logs state transitions for monitoring\n";
    code += " * @param fromState Source state name\n";
    code += " * @param toState Target state name\n";
    code += " */\n";
    code += "void logStateChange(const QString& fromState, const QString& toState) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"\";\n";  // Add empty line before state change for separation
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" \n";
    code += "             << ANSI_BOLD + ANSI_VOID_PURPLE + \"STATE CHANGE\" + ANSI_RESET + \": \"\n";
    code += "             << ANSI_OBLIVION_BLUE + fromState + ANSI_RESET \n";
    code += "             << \" → \" \n";  // Use Unicode arrow for better visual flow
    code += "             << ANSI_BOLD + ANSI_VOID_PURPLE + toState + ANSI_RESET;\n";
    code += "}\n\n";
    
    // Input event logging function
    code += "/**\n";
    code += " * @brief Logs input values for monitoring\n";
    code += " * @param input Input name\n";
    code += " * @param value Input value\n";
    code += " */\n";
    code += "void logInputEvent(const QString& input, const QString& value) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\"\n";
    code += "             << ANSI_OBLIVION_BLUE + \"INPUT\" + ANSI_RESET + \": \"\n";
    code += "             << \"  \" + ANSI_BOLD + input + ANSI_RESET \n";
    code += "             << \" = \" \n";
    code += "             << ANSI_SILVER + value + ANSI_RESET;\n";
    code += "}\n\n";
    
    // Output event logging function
    code += "/**\n";
    code += " * @brief Logs output values for monitoring\n";
    code += " * @param output Output name\n";
    code += " * @param value Output value\n";
    code += " */\n";
    code += "void logOutputEvent(const QString& output, const QString& value) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\"\n";
    code += "             << ANSI_VOID_PURPLE + \"OUTPUT\" + ANSI_RESET + \": \"\n";
    code += "             << \"  \" + ANSI_BOLD + output + ANSI_RESET \n";
    code += "             << \" = \" \n";
    code += "             << ANSI_SILVER + value + ANSI_RESET;\n";
    code += "}\n\n";
    
    // Debug print function for general debugging messages
    code += "/**\n";
    code += " * @brief Prints a debug message with timestamp\n";
    code += " * @param message Debug message to display\n";
    code += " * @param level Debug level (0=INFO, 1=NOTICE, 2=WARNING, 3=ERROR)\n";
    code += " */\n";
    code += "void debugPrint(const QString& message, int level = 0) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    QString prefix;\n";
    code += "    switch (level) {\n";
    code += "        case 0: prefix = ANSI_OBLIVION_BLUE + \"INFO\" + ANSI_RESET + \": \"; break;\n";
    code += "        case 1: prefix = ANSI_SILVER + \"NOTICE\" + ANSI_RESET + \": \"; break;\n";
    code += "        case 2: prefix = ANSI_OBLIVION_BLUE + \"WARNING\" + ANSI_RESET + \": \"; break;\n";
    code += "        case 3: prefix = ANSI_MAGENTA + \"ERROR\" + ANSI_RESET + \": \"; break;\n";
    code += "        default: prefix = \"DEBUG: \";\n";
    code += "    }\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" << prefix << message;\n";
    code += "}\n\n";

    return code;
}

/**
 * @brief Generate code for a transition
 * @param transition The transition
 * @param sourceState Source state
 * @param targetState Target state
 * @return Generated C++ code for the transition
 */
QString CodeGen::generateTransitionCode(Transition *transition, 
                                     const State *sourceState, 
                                     const State *targetState) {
    QString code;
    QString sourceName = const_cast<State*>(sourceState)->getName();
    QString targetName = const_cast<State*>(targetState)->getName();
    QString sourceLower = sourceName.toLower();
    QString targetLower = targetName.toLower();
    
    // Get transition properties
    QString condition = transition->getCondition();
    int delay = transition->isDelayedTransition() ? transition->getDelay() : 0;
    bool hasCondition = !condition.isEmpty();
    bool hasDelay = delay > 0;
    
    // Variable name for the transition
    QString transName = sourceLower + "To" + targetName + "Transition";
    
    // Create the unified transition
    code += "    // Create unified transition: " + sourceName + " → " + targetName;
    
    // Add condition and/or delay information to the comment
    if (hasCondition || hasDelay) {
        code += " (";
        if (hasCondition) {
            code += "[ " + condition + " ]";
        }
        if (hasDelay) {
            if (hasCondition) code += " ";
            code += "@ " + QString::number(delay) + "ms";
        }
        code += ")";
    }
    code += "\n";
    
    // Create the transition object
    code += "    UnifiedTransition* " + transName + " = new UnifiedTransition(";
    
    // Add condition lambda if present
    if (hasCondition) {
        code += "[]() -> bool {\n";
        code += "        // Evaluate condition: " + condition + "\n";
        code += "        return " + condition + ";\n";
        code += "    }";
    } else {
        code += "[]() { return true; }"; // Default condition always true
    }
    
    // Add delay if present
    code += ", " + QString::number(delay);
    
    // Add source and target state names for logging
    code += ", \"" + sourceName + "\", \"" + targetName + "\"";
    
    // Add condition string for logging
    if (hasCondition) {
        code += ", \"" + condition.replace("\"", "\\\"") + "\"";
    }
    
    code += ");\n";
    
    // Add the transition to the state machine
    code += "    " + sourceLower + "State->addTransition(" + transName + ");\n";
    code += "    " + transName + "->setTargetState(" + targetLower + "State);\n\n";
    
    return code;
}

/**
 * @brief Generates a main function that uses QStateMachine
 * 
 * Creates the main function that uses Qt's built-in QStateMachine rather
 * than a manual switch-case approach. This leverages Qt's state machine framework
 * for cleaner code and better integration with Qt's event system.
 * 
 * @param fsm FSM containing the states and transitions
 * @return Code section as QString
 */
QString CodeGen::generateQStateMachineMain(FSM *fsm)
{
    QString code;
    
    // Add section header comment
    code += "/******************************************************************************\n";
    code += " * Main function with QStateMachine\n";
    code += " ******************************************************************************/\n\n";

    // Get the initial state
    State *initial = fsm->getInitialState();
    QMap<QString, State*> allStates = fsm->getStates();
    
    QString initialStateName = initial ? initial->getName() : "UNKNOWN";

    // Define the classes needed for QStateMachine
    code += "/**\n";
    code += " * @brief Unified transition class handling both conditions and delays\n";
    code += " */\n";
    code += "class UnifiedTransition : public QAbstractTransition {\n";
    code += "public:\n";
    code += "    /**\n";
    code += "     * @brief Constructor for a unified transition that handles both conditions and delays\n";
    code += "     * @param condition A lambda function that evaluates to a boolean\n";
    code += "     * @param delayMs Delay in milliseconds before triggering the transition (0 = no delay)\n";
    code += "     * @param fromState Source state name (for logging)\n";
    code += "     * @param toState Target state name (for logging)\n";
    code += "     * @param conditionStr String representation of the condition (for logging)\n";
    code += "     */\n";
    code += "    explicit UnifiedTransition(std::function<bool()> condition = []() { return true; },\n";
    code += "                             int delayMs = 0,\n";
    code += "                             const QString& fromState = QString(),\n";
    code += "                             const QString& toState = QString(),\n";
    code += "                             const QString& conditionStr = QString())\n";
    code += "        : m_condition(std::move(condition)),\n";
    code += "          m_delay(delayMs),\n";
    code += "          m_fromState(fromState),\n";
    code += "          m_toState(toState),\n";
    code += "          m_conditionStr(conditionStr),\n";
    code += "          m_timer(nullptr),\n";
    code += "          m_conditionMet(false)\n";
    code += "    {\n";
    code += "        if (m_delay > 0) {\n";
    code += "            m_timer = new QTimer(this);\n";
    code += "            m_timer->setSingleShot(true);\n";
    code += "            connect(m_timer, &QTimer::timeout, this, &UnifiedTransition::triggerTransition);\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "protected:\n";
    code += "    /**\n";
    code += "     * @brief Tests whether the transition should be triggered\n";
    code += "     * @param event The event triggering the transition\n";
    code += "     * @return True if the transition should occur, false otherwise\n";
    code += "     */\n";
    code += "    bool eventTest(QEvent* event) override {\n";
    code += "        // If this is our custom timeout event and the condition was met previously\n";
    code += "        if (event->type() == QEvent::User + 1 && m_conditionMet) {\n";
    code += "            return true;\n";
    code += "        }\n";
    code += "        \n";
    code += "        // For all other events, we check the condition\n";
    code += "        try {\n";
    code += "            m_conditionMet = m_condition();\n";
    code += "            \n";
    code += "            // If condition failed, stop any running timer and return false\n";
    code += "            if (!m_conditionMet) {\n";
    code += "                cancelTimerIfActive();\n";
    code += "                return false;\n";
    code += "            }\n";
    code += "            \n";
    code += "            // Condition passed - if we have a delay, start the timer (if not already running)\n";
    code += "            if (m_delay > 0) {\n";
    code += "                if (m_timer && !m_timer->isActive()) {\n";
    code += "                    logTransitionStart();\n";
    code += "                    m_timer->start(m_delay);\n";
    code += "                }\n";
    code += "                return false; // Don't trigger yet, wait for timer\n";
    code += "            }\n";
    code += "            \n";
    code += "            // No delay, trigger immediately\n";
    code += "            return m_conditionMet;\n";
    code += "        } catch (const std::exception& e) {\n";
    code += "            debugPrint(\"Error evaluating transition condition: \" + QString::fromStdString(e.what()), 3);\n";
    code += "            return false;\n";
    code += "        } catch (...) {\n";
    code += "            debugPrint(\"Unknown error evaluating transition condition\", 3);\n";
    code += "            return false;\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "    /**\n";
    code += "     * @brief Logs the transition when it occurs\n";
    code += "     * @param event The event triggering the transition\n";
    code += "     */\n";
    code += "    void onTransition(QEvent* event) override {\n";
    code += "        Q_UNUSED(event);\n";
    code += "        \n";
    code += "        debugPrint(DOUBLE_SEPARATOR);\n";
    code += "        debugPrint(\"Transition: \" + \n";
    code += "                  ANSI_BOLD + ANSI_CYAN + m_fromState + ANSI_RESET + \n";
    code += "                  \" → \" + \n";
    code += "                  ANSI_BOLD + ANSI_GREEN + m_toState + ANSI_RESET);\n";
    code += "        \n";
    code += "        if (!m_conditionStr.isEmpty()) {\n";
    code += "            debugPrint(\"  Condition satisfied: \" + m_conditionStr);\n";
    code += "        }\n";
    code += "        \n";
    code += "        if (m_delay > 0) {\n";
    code += "            debugPrint(\"  Delay completed: \" + QString::number(m_delay) + \"ms\");\n";
    code += "        }\n";
    code += "        debugPrint(SECTION_SEPARATOR);\n";
    code += "        \n";
    code += "        // Reset condition state after transition\n";
    code += "        m_conditionMet = false;\n";
    code += "    }\n\n";
    
    code += "private slots:\n";
    code += "    /**\n";
    code += "     * @brief Triggers the transition after the delay timer expires\n";
    code += "     */\n";
    code += "    void triggerTransition() {\n";
    code += "        // We only want to post the event if the condition is still true\n";
    code += "        if (m_condition()) {\n";
    code += "            QEvent* customEvent = new QEvent(static_cast<QEvent::Type>(QEvent::User + 1));\n";
    code += "            machine()->postEvent(customEvent);\n";
    code += "        } else {\n";
    code += "            m_conditionMet = false;\n";
    code += "            debugPrint(\"Condition no longer valid after delay for transition \" + \n";
    code += "                      m_fromState + \" → \" + m_toState + \n";
    code += "                      \", not triggering\");\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "private:\n";
    code += "    /**\n";
    code += "     * @brief Helper method to cancel the timer if it's active\n";
    code += "     */\n";
    code += "    void cancelTimerIfActive() {\n";
    code += "        if (m_timer && m_timer->isActive()) {\n";
    code += "            m_timer->stop();\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "    /**\n";
    code += "     * @brief Helper method to log transition start with consistent formatting\n";
    code += "     */\n";
    code += "    void logTransitionStart() {\n";
    code += "        debugPrint(\"Condition met for transition \" + \n";
    code += "                  ANSI_CYAN + m_fromState + ANSI_RESET + \" → \" + \n";
    code += "                  ANSI_GREEN + m_toState + ANSI_RESET + \n";
    code += "                  \", starting \" + QString::number(m_delay) + \"ms delay timer\");\n";
    code += "    }\n\n";
    
    code += "    std::function<bool()> m_condition;  ///< The condition to evaluate\n";
    code += "    int m_delay;                        ///< Delay in milliseconds (0 = no delay)\n";
    code += "    QString m_fromState;                ///< Source state name for logging\n";
    code += "    QString m_toState;                  ///< Target state name for logging\n";
    code += "    QString m_conditionStr;             ///< Condition string for logging\n";
    code += "    QTimer* m_timer;                    ///< Timer for delayed transitions\n";
    code += "    bool m_conditionMet;                ///< Tracks whether the condition was met\n";
    code += "};\n\n";

    code += "/**\n";
    code += " * @brief Custom event for input changes\n";
    code += " */\n";
    code += "class InputEvent : public QEvent {\n";
    code += "public:\n";
    code += "    static const QEvent::Type InputChangedType = static_cast<QEvent::Type>(QEvent::User + 2);\n\n";
    
    code += "    InputEvent(const QString& name, const QString& value) \n";
    code += "        : QEvent(InputChangedType), m_name(name), m_value(value) {}\n\n";
    
    code += "    QString name() const { return m_name; }\n";
    code += "    QString value() const { return m_value; }\n\n";
    
    code += "private:\n";
    code += "    QString m_name;\n";
    code += "    QString m_value;\n";
    code += "};\n\n";

    code += "/**\n";
    code += " * @brief Main function that uses QStateMachine for state management\n";
    code += " */\n";
    code += "int main(int argc, char *argv[]) {\n";
    code += "    QCoreApplication app(argc, argv);\n";
    code += "    \n";
    code += "    // Application header with cosmic void visualization\n";
    code += "    qDebug().noquote() << \"\\n\" + DOUBLE_SEPARATOR;\n";
    code += "    qDebug().noquote() << ANSI_BOLD + ANSI_VOID_PURPLE + \"✧ ✧ ✧  OBLIVION STATE MACHINE  ✧ ✧ ✧\" + ANSI_RESET;\n";
    code += "    qDebug().noquote() << ANSI_OBLIVION_BLUE + \"     Navigating the cosmic void of software states\" + ANSI_RESET;\n";
    code += "    qDebug().noquote() << DOUBLE_SEPARATOR + \"\\n\";\n";
    code += "    \n";
    code += "    debugPrint(\"Starting FSM application with QStateMachine\");\n";
    code += "    debugPrint(\"State machine name: \" + ANSI_BOLD + ANSI_VOID_PURPLE + \"" + fsm->getName() + "\" + ANSI_RESET);\n";
    
    // Add signal handler for SIGINT (Ctrl+C)
    code += "    // Setup signal handler for Ctrl+C (SIGINT)\n";
    code += "    std::signal(SIGINT, [](int) {\n";
    code += "        qDebug().noquote() << \"\";\n";  // Add empty line for clarity
    code += "        debugPrint(ANSI_BOLD + ANSI_MAGENTA + \"Interrupt received. Exiting gracefully...\" + ANSI_RESET);\n";
    code += "        QCoreApplication::quit();\n";
    code += "    });\n\n";

    // Extract and initialize inputs/outputs
    QSet<QString> inputNames = fsm->getInputs();
    QSet<QString> outputNames = fsm->getOutputs();
    
    code += "    // Initialize inputs and outputs\n";
    for (const QString& input : inputNames) {
        code += "    inputs[QStringLiteral(\"" + input.trimmed() + "\")] = QString();\n";
    }
    
    for (const QString& output : outputNames) {
        code += "    outputs[QStringLiteral(\"" + output.trimmed() + "\")] = QString();\n";
    }
    code += "\n";
    
    // Create the state machine object
    code += "    // Create state machine\n";
    code += "    QStateMachine fsm;\n";
    code += "    fsm.setObjectName(\"" + fsm->getName() + "\");\n\n";
    
    // Enhanced state creation display
    code += "    // Create all states\n";
    code += "    debugPrint(\"Creating states...\");\n";

    // Iterate through states using the map from FSM
    for (auto it = allStates.begin(); it != allStates.end(); ++it) {
        State* state = it.value();
        QString stateName = state->getName();
        QString stateLower = stateName.toLower();
        
        code += "    QState* " + stateLower + "State = new QState(&fsm);\n";
        code += "    " + stateLower + "State->setObjectName(\"" + stateName + "\");\n";
        code += "    debugPrint(\"  Created state: \" + ANSI_CYAN + \"" + stateName + "\" + ANSI_RESET);\n";
        
        // Add onEntry code if available
        QString onEntry = state->getCode();
        if (!onEntry.isEmpty()) {
            code += "    QObject::connect(" + stateLower + "State, &QState::entered, []() {\n";
            code += "        debugPrint(DOUBLE_SEPARATOR);\n";
            code += "        debugPrint(STATE_HEADER + ANSI_BOLD + ANSI_VOID_PURPLE + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "        debugPrint(\"Executing onEntry action for state: \" + ANSI_BOLD + \"" + stateName + "\" + ANSI_RESET);\n";
            code += "        " + onEntry + "\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "    });\n";
        } else {
            // Even if no onEntry code, still provide visual feedback for state entry
            code += "    QObject::connect(" + stateLower + "State, &QState::entered, []() {\n";
            code += "        debugPrint(DOUBLE_SEPARATOR);\n";
            code += "        debugPrint(STATE_HEADER + ANSI_BOLD + ANSI_VOID_PURPLE + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "    });\n";
        }
        code += "\n";
    }
    
    // Set initial state
    code += "    // Set initial state\n";
    code += "    fsm.setInitialState(" + initialStateName.toLower() + "State);\n";
    code += "    debugPrint(\"Initial state set to \" + ANSI_BOLD + ANSI_GREEN + \"" + initialStateName + "\" + ANSI_RESET);\n\n";
    
    // Create transitions between states
    code += "    // Create transitions between states\n";
    code += "    debugPrint(\"Setting up transitions...\");\n";
    
    // Iterate through all states and their transitions
    for (auto stateIt = allStates.begin(); stateIt != allStates.end(); ++stateIt) {
        State* sourceState = stateIt.value();
        QString sourceName = sourceState->getName();
        
        // Get all transitions from this state
        QList<Transition*> transitions = fsm->getTransitionsFrom(sourceState);
        
        for (Transition* transition : transitions) {
            State* targetState = transition->getTo();
            if (!targetState) continue;
            
            QString targetName = targetState->getName();
            
            // Display the transition info with condition and/or delay
            code += "    // Create transition: " + sourceName + " → " + targetName;
            
            QString condition = transition->getCondition();
            bool hasDelay = transition->isDelayedTransition();
            
            if (!condition.isEmpty() || hasDelay) {
                code += " (";
                if (!condition.isEmpty()) {
                    code += "[ " + condition + " ]";
                }
                if (hasDelay) {
                    if (!condition.isEmpty()) code += " ";
                    code += "@ " + QString::number(transition->getDelay());
                }
                code += ")";
            }
            
            code += "\n";
            
            // Generate the transition code
            code += generateTransitionCode(transition, sourceState, targetState);
        }
    }
    
    // Rest of the main function (command handling, etc.)
    code += "    // Print application usage help\n";
    code += "    debugPrint(\"Available Commands:\");\n";
    code += "    debugPrint(SECTION_SEPARATOR);\n";
    code += "    qDebug().noquote() << ANSI_BOLD + QString(\"name=value\").leftJustified(15) + ANSI_RESET + \"- Set an input value\";\n";
    code += "    qDebug().noquote() << ANSI_BOLD + QString(\"status\").leftJustified(15) + ANSI_RESET + \"- Show the current system state\";\n";
    code += "    qDebug().noquote() << ANSI_BOLD + QString(\"help\").leftJustified(15) + ANSI_RESET + \"- Show this help message\";\n";
    code += "    qDebug().noquote() << ANSI_BOLD + QString(\"quit/exit\").leftJustified(15) + ANSI_RESET + \"- Exit the application\";\n";
    code += "    debugPrint(SECTION_SEPARATOR + \"\\n\");\n\n";

    // Add terminal input setup
    code += "    // Setup input handling from the terminal\n";
    code += "    FILE* terminalInput = fdopen(dup(STDIN_FILENO), \"r\");\n";
    code += "    if (!terminalInput) {\n";
    code += "        debugPrint(\"Error: Could not open terminal input\", 3);\n";
    code += "        return 1;\n";
    code += "    }\n\n";
    
    // Create a notifier for terminal input
    code += "    // Create a notifier for terminal input\n";
    code += "    int terminalFd = fileno(terminalInput);\n";
    code += "    QSocketNotifier* inputNotifier = new QSocketNotifier(terminalFd, QSocketNotifier::Read);\n\n";
    
    // Updated input handler with streamlined logging and reduced repetition
    code += "    QObject::connect(inputNotifier, &QSocketNotifier::activated, [&]() {\n";
    code += "        // Read from the terminal\n";
    code += "        char buffer[1024];\n";
    code += "        if (fgets(buffer, sizeof(buffer), terminalInput)) {\n";
    code += "            QString line = QString::fromUtf8(buffer).trimmed();\n";
    code += "            \n";
    code += "            if (line.isEmpty()) {\n";
    code += "                inputNotifier->setEnabled(true);\n";
    code += "                return;\n";
    code += "            }\n";
    code += "            \n";
    code += "            // Get current state for context\n";
    code += "            QString currentState = fsm.configuration().isEmpty() ? \"UNKNOWN\" : \n";
    code += "                                  (*fsm.configuration().begin())->objectName();\n";
    code += "            \n";
    code += "            // Show command header for any input\n";
    code += "            qDebug().noquote() << \"\\n\" + COMMAND_HEADER + line;\n";
    code += "            \n";
    code += "            if (line.contains('=')) {\n";
    code += "                int pos = line.indexOf('=');\n";
    code += "                QString name = line.left(pos);\n";
    code += "                QString value = line.mid(pos + 1);\n";
    code += "                \n";
    code += "                // Single consolidated message for input handling\n";
    code += "                debugPrint(\"Received input in state \" + ANSI_GREEN + currentState + ANSI_RESET + \": \" + \n";
    code += "                          ANSI_BOLD + name + ANSI_RESET + \" = \" + ANSI_CYAN + value + ANSI_RESET);\n";
    code += "                \n";
    code += "                inputs[name] = value;\n";
    code += "                fsm.postEvent(new InputEvent(name, value));\n";
    code += "            } else if (line == \"exit\" || line == \"quit\") {\n";
    code += "                debugPrint(ANSI_BOLD + ANSI_RED + \"Exit command received. Terminating application...\" + ANSI_RESET);\n";
    code += "                app.quit();\n";
    code += "            } else if (line == \"status\") {\n";
    code += "                // Enhanced status display with bullet points and consistent formatting\n";
    code += "                qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "                qDebug().noquote() << \"[\" << timeMs << \"]\" << ANSI_BOLD + ANSI_OBLIVION_BLUE + \"SYSTEM STATUS\" + ANSI_RESET;\n";
    code += "                qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "                \n";
    code += "                // Current state - always shown\n";
    code += "                qDebug().noquote() << \"• Current state: \" + ANSI_BOLD + ANSI_VOID_PURPLE + currentState + ANSI_RESET;\n";
    code += "                \n";
    code += "                // Print inputs with bullet points\n";
    code += "                if (!inputs.isEmpty()) {\n";
    code += "                    qDebug().noquote() << \"\\n• Input values:\";\n";
    code += "                    for (auto it = inputs.constBegin(); it != inputs.constEnd(); ++it) {\n";
    code += "                        qDebug().noquote() << \"  ◦ \" + ANSI_OBLIVION_BLUE + it.key() + ANSI_RESET + \" = \" + \n";
    code += "                                        (it.value().isEmpty() ? ANSI_SILVER + \"<empty>\" + ANSI_RESET : it.value());\n";
    code += "                    }\n";
    code += "                }\n";
    code += "                \n";
    code += "                // Print outputs with bullet points\n";
    code += "                if (!outputs.isEmpty()) {\n";
    code += "                    qDebug().noquote() << \"\\n• Output values:\";\n";
    code += "                    for (auto it = outputs.constBegin(); it != outputs.constEnd(); ++it) {\n";
    code += "                        qDebug().noquote() << \"  ◦ \" + ANSI_VOID_PURPLE + it.key() + ANSI_RESET + \" = \" + \n";
    code += "                                        (it.value().isEmpty() ? ANSI_SILVER + \"<empty>\" + ANSI_RESET : it.value());\n";
    code += "                    }\n";
    code += "                }\n";
    code += "                qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "            } else if (line == \"help\") {\n";
    code += "                // Help display with better spacing and bulletpoints\n";
    code += "                qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "                qDebug().noquote() << \"[\" << timeMs << \"]\" << ANSI_BOLD + ANSI_OBLIVION_BLUE + \"AVAILABLE COMMANDS\" + ANSI_RESET;\n";
    code += "                qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "                qDebug().noquote() << \"• \" + ANSI_BOLD + QString(\"name=value\").leftJustified(15) + ANSI_RESET + \"- Set an input value\";\n";
    code += "                qDebug().noquote() << \"• \" + ANSI_BOLD + QString(\"status\").leftJustified(15) + ANSI_RESET + \"- Show the current system state\";\n";
    code += "                qDebug().noquote() << \"• \" + ANSI_BOLD + QString(\"help\").leftJustified(15) + ANSI_RESET + \"- Show this help message\";\n";
    code += "                qDebug().noquote() << \"• \" + ANSI_BOLD + QString(\"quit/exit\").leftJustified(15) + ANSI_RESET + \"- Exit the application\";\n";
    code += "                qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "            } else {\n";
    code += "                debugPrint(\"Unknown command: \" + ANSI_BOLD + \"\\\"\" + line + \"\\\"\" + ANSI_RESET + \n";
    code += "                          \". Type 'help' to see available commands.\", 2);\n";
    code += "            }\n";
    code += "        }\n";
    code += "        \n";
    code += "        // Re-enable the notifier\n";
    code += "        inputNotifier->setEnabled(true);\n";
    code += "    });\n\n";

    // Start the state machine with cosmic void aesthetic
    code += "    // Start the state machine with cosmic void aesthetic\n";
    code += "    debugPrint(DOUBLE_SEPARATOR);\n";
    code += "    debugPrint(ANSI_BOLD + ANSI_VOID_PURPLE + \"INITIALIZING OBLIVION STATE MACHINE\" + ANSI_RESET);\n";
    code += "    fsm.start();\n";
    code += "    debugPrint(\"Transition engine activated successfully\");\n";
    code += "    debugPrint(DOUBLE_SEPARATOR);\n";
    code += "    qDebug().noquote() << \"\"; // Empty line for better readability\n\n";
    
    code += "    // Run the application\n";
    code += "    int result = app.exec();\n";
    code += "    debugPrint(DOUBLE_SEPARATOR);\n";
    code += "    debugPrint(\"Application terminated with code \" + QString::number(result));\n";
    code += "    return result;\n";
    code += "}\n";
    
    return code;
}
