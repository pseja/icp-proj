#include "CodeGen.hpp"

#include <QDebug>
#include <QRegularExpression>
#include <csignal>

#include "fsm.hpp"
#include "state.hpp"
#include "transition.hpp"
#include "variable.hpp"

/**
 * @brief Constructor for the CodeGen class
 * @param parent The parent QObject
 */
CodeGen::CodeGen(QObject* parent) : QObject(parent) {
}

/**
 * @brief Top-level entry for generating code from an FSM memory representation
 * @param fsm The state machine to generate code from
 * @return Generated C++ code as a QString
 */
QString CodeGen::generateCode(FSM* fsm) {
  QString code;

  code += "/**\n";
  code += " * Generated Finite State Machine: " + fsm->getName() + "\n";

  QString description = fsm->getComment();
  if (!description.isEmpty()) {
    code += " * Description: " + description + "\n";
  }

  code += " * \n";
  code += " * This file was automatically generated by ICP FSM Code Generator\n";
  code += " */\n\n";

  code += generateHeaders();
  code += generateVariableDeclarations(fsm);
  code += generateRuntimeMonitoring();
  code += generateHelperFunctions();
  code += generateQStateMachineMain(fsm);

  return code;
}

/**
 * @brief Generates standard C++ header includes
 * @return Code section as QString
 */
QString CodeGen::generateHeaders() {
  QString code;

  code += "#include <QtCore/QDebug>\n";
  code += "#include <QtCore/QString>\n";
  code += "#include <QtCore/QMap>\n";
  code += "#include <QtCore/QDateTime>\n";
  code += "#include <QtCore/QCoreApplication>\n";
  code += "#include <QtCore/QTimer>\n";
  code += "#include <QtCore/QSocketNotifier>\n";
  code += "#include <QtCore/QStateMachine>\n";
  code += "#include <QtCore/QState>\n";
  code += "#include <QtCore/QEvent>\n";
  code += "#include <QtCore/QAbstractTransition>\n";
  code += "#include <QtCore/QRegularExpression>\n";
  code += "#include <stdio.h>\n";
  code += "#include <unistd.h>\n";
  code += "#include <csignal>\n";
  code += "#include <functional>\n";
  code += "\n";

  return code;
}

/**
 * @brief Provides basic helpers for managing input/output values
 * @return Code section as QString
 */
QString CodeGen::generateHelperFunctions() {
  QString code;

  code += "/******************************************************************************\n";
  code += " * Utility functions for input/output and value handling\n";
  code += " ******************************************************************************/\n\n";

  code += "/**\n";
  code += " * @brief Gets the string value of an input\n";
  code += " * @param input Input name\n";
  code += " * @return Current string value of the input, or empty string if not found\n";
  code += " */\n";
  code += "QString valueof(const QString &input) {\n";
  code += "    if (inputs.contains(input)) {\n";
  code += "        return inputs[input];\n";
  code += "    }\n";
  code += "    return QString();\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Converts a string to an integer\n";
  code += " * @param str String to convert\n";
  code += " * @return Integer value, or 0 if conversion fails\n";
  code += " */\n";
  code += "int atoi(const QString &str) {\n";
  code += "    bool ok = false;\n";
  code += "    int value = str.toInt(&ok);\n";
  code += "    return ok ? value : 0;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Checks if an input is defined and has a non-empty value\n";
  code += " * @param input Input name to check\n";
  code += " * @return True if the input exists and has a value\n";
  code += " */\n";
  code += "bool defined(const QString &input) {\n";
  code += "    return inputs.contains(input) && !inputs[input].isEmpty();\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Sends an output value to a specific port\n";
  code += " * @param port Output port name\n";
  code += " * @param value Integer value to send\n";
  code += " */\n";
  code += "void output(const QString &port, int value) {\n";
  code += "    outputs[port] = QString::number(value);\n";
  code += "    logOutputEvent(port, QString::number(value));\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Returns time elapsed since state entry in milliseconds\n";
  code += " * @return Milliseconds elapsed since entering the current state\n";
  code += " */\n";
  code += "int elapsed() {\n";
  code += "    if (fsm.configuration().isEmpty()) { return 0; }\n";
  code += "    QState* currentState = static_cast<QState*>(*fsm.configuration().begin());\n";
  code += "    qint64 entryTime = currentState->property(\"entryTime\").toLongLong();\n";
  code += "    if (entryTime == 0) { \n";
  code += "       return 0; \n";
  code += "    }\n";
  code += "    return QDateTime::currentDateTime().toMSecsSinceEpoch() - entryTime;\n";
  code += "}\n\n";

  code += "// Shared event flags for tracking input calls\n";
  code += "QMap<QString, bool>& getEventFlags() {\n";
  code += "    static QMap<QString, bool>* flags = new QMap<QString, bool>();\n";
  code += "    return *flags;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Checks if an input was called as an event (regardless of value)\n";
  code += " * @param input Input name to check\n";
  code += " * @return True if the input was triggered as an event\n";
  code += " */\n";
  code += "bool called(const QString &input) {\n";
  code += "    QMap<QString, bool>& eventFlags = getEventFlags();\n";
  code += "    bool result = eventFlags.value(input, false);\n";
  code += "    debug(QString(\"called('%1') returning %2\").arg(input).arg(result ? \"true\" : \"false\"));\n";
  code += "    eventFlags[input] = false;\n";
  code += "    return result;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Sets the trigger flag for an input\n";
  code += " * @param input Input name to mark as called\n";
  code += " */\n";
  code += "void setInputCalled(const QString &input) {\n";
  code += "    QMap<QString, bool>& eventFlags = getEventFlags();\n";
  code += "    eventFlags[input] = true;\n";
  code += "}\n\n";

  return code;
}

/**
 * @brief Generates global declarations for standard and custom FSM variables
 * @param fsm State machine containing variable definitions
 * @return Code section as QString
 */
QString CodeGen::generateVariableDeclarations(FSM* fsm) {
  QString code;

  code += "/******************************************************************************\n";
  code += " * Variable declarations\n";
  code += " ******************************************************************************/\n\n";

  code += "QStateMachine fsm;              // Global state machine instance\n";
  code += "QMap<QString, QString> inputs;  // Map of input names to values\n";
  code += "QMap<QString, QString> outputs; // Map of output names to values\n";
  code += "bool debugEnabled = false;\n\n";

  QMap<QString, Variable*> variables = fsm->getVariables();
  if (!variables.isEmpty()) {
    code += "// Custom variables for " + fsm->getName() + "\n";

    for (auto it = variables.constBegin(); it != variables.constEnd(); ++it) {
      Variable* var = it.value();
      code += var->getType() + " " + var->getName() + " = " + var->getValue().toString() + ";\n";
    }
    code += "\n";
  }

  return code;
}

/**
 * @brief Provides logging functions for state transitions, events, and debugging
 * @return Code section as QString
 */
QString CodeGen::generateRuntimeMonitoring() {
  QString code;

  code += "/******************************************************************************\n";
  code += " * Runtime monitoring and debugging\n";
  code += " ******************************************************************************/\n\n";

  code += "// ANSI basic formatting codes\n";
  code += "const QString ANSI_RESET = \"\\033[0m\";\n";
  code += "const QString ANSI_BOLD = \"\\033[1m\";\n";
  code += "\n";

  code += "const QString COSMIC_PURPLE = \"\\033[38;5;93m\";    // Rich cosmic purple, used for state names & headers\n";
  code += "const QString NEBULA_BLUE = \"\\033[38;5;39m\";      // Bright nebula blue, used for transition info and info level logs\n";
  code += "const QString SPACE_TEAL = \"\\033[38;5;31m\";       // Deep space teal, used for input values\n";
  code += "const QString STARDUST = \"\\033[38;5;153m\";        // Light blue stardust, used for variable values\n";
  code += "const QString STAR_WHITE = \"\\033[38;5;231m\";      // Bright star white, used for command headers\n";
  code += "const QString COSMIC_DUST = \"\\033[38;5;102m\";     // Faded cosmic dust, used for source states and notice level logs\n";
  code += "const QString TIMEOUT_STARTED = \"\\033[38;5;177m\"; // Light purple for timeout started\n";
  code += "const QString TIMEOUT_EXPIRED = \"\\033[38;5;213m\"; // Pink for timeout expired\n";
  code += "const QString STELLAR_PURPLE = \"\\033[38;5;141m\";  // Bright stellar purple, used for section headers\n";
  code += "const QString PULSAR_YELLOW = \"\\033[38;5;220m\";   // Pulsating yellow, used for warnings\n";
  code += "const QString QUANTUM_GREEN = \"\\033[38;5;84m\";    // Quantum field green, used for target states and success messages\n";
  code += "const QString WARP_RED = \"\\033[38;5;196m\";        // Warp field red, used for error messages\n\n";

  code += "// Semantic color mappings - function-based color assignments\n";
  code += "const QString COLOR_STATE = COSMIC_PURPLE;    // State names & headers\n";
  code += "const QString COLOR_TRANSITION = NEBULA_BLUE; // Transition information\n";
  code += "const QString COLOR_SOURCE = COSMIC_DUST;     // Source states\n";
  code += "const QString COLOR_TARGET = QUANTUM_GREEN;   // Target states\n";
  code += "const QString COLOR_COMMAND = STAR_WHITE;     // Command headers\n";
  code += "const QString COLOR_VALUE = STARDUST;         // Variable values\n";
  code += "const QString COLOR_INFO = NEBULA_BLUE;       // Info level logs\n";
  code += "const QString COLOR_NOTICE = COSMIC_DUST;     // Notice level logs\n";
  code += "const QString COLOR_WARNING = PULSAR_YELLOW;  // Warning level logs\n";
  code += "const QString COLOR_ERROR = WARP_RED;         // Error level logs\n";
  code += "const QString COLOR_SUCCESS = QUANTUM_GREEN;  // Success messages\n";
  code += "const QString COLOR_HEADER = STELLAR_PURPLE;  // Section headers\n\n";

  code += "const QString SYM_BULLET = \"•\";\n";
  code += "const QString SYM_STAR = \"✧\";\n";
  code += "const QString SYM_TRIANGLE = \"▶\";\n";
  code += "const QString SYM_ARROW = \"→\";\n";
  code += "const QString SYM_SUCCESS = \"✓\";\n";

  code += "const QString STATE_HEADER = ANSI_BOLD + COLOR_STATE + \"════════ STATE: \" + ANSI_RESET;\n";
  code += "const QString COMMAND_HEADER = ANSI_BOLD + COLOR_COMMAND + \"⟫ COMMAND: \" + ANSI_RESET;\n";
  code += "const QString SECTION_SEPARATOR = COLOR_NOTICE + \"───────────────────────────────────────────────────\" + ANSI_RESET;\n";
  code += "const QString DOUBLE_SEPARATOR = COLOR_TRANSITION + \"═══════════════════════════════════════════════════\" + ANSI_RESET;\n\n";

  code += "/**\n";
  code += " * @brief Prints a log message\n";
  code += " * @param message Log message to display\n";
  code += " */\n";
  code += "void log(const QString& message) {\n";
  code += "    QString timeStr = QDateTime::currentDateTime().toString(\"HH:mm:ss.zzz\");\n";
  code += "    qDebug().noquote() << \"[\" << timeStr << \"]\" << message;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Logs state transitions for monitoring\n";
  code += " * @param stateName State name being entered\n";
  code += " */\n";
  code += "void logStateChange(const QString& stateName) {\n";
  code += "    log(DOUBLE_SEPARATOR);\n";
  code += "    log(STATE_HEADER + ANSI_BOLD + COLOR_STATE + stateName + ANSI_RESET + \" ENTERED\");\n";
  code += "    log(SECTION_SEPARATOR);\n";
  code += "    log(\"Executing onEntry action for state: \" + ANSI_BOLD + stateName + ANSI_RESET);\n";
  code += "    log(SECTION_SEPARATOR);\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Logs input values for monitoring\n";
  code += " * @param input Input name\n";
  code += " * @param value Input value\n";
  code += " */\n";
  code += "void logInputEvent(const QString& input, const QString& value) {\n";
  code += "    log(\"Input value: \" + ANSI_BOLD + input + ANSI_RESET + \" = \" + COLOR_VALUE + value + ANSI_RESET);\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Logs output values for monitoring\n";
  code += " * @param output Output name\n";
  code += " * @param value Output value\n";
  code += " */\n";
  code += "void logOutputEvent(const QString& output, const QString& value) {\n";
  code += "    log(\"Output value: \" + ANSI_BOLD + output + ANSI_RESET + \" = \" + COLOR_VALUE + value + ANSI_RESET);\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Prints a debug message if debugEnabled is true\n";
  code += " * @param message Debug message to display\n";
  code += " */\n";
  code += "void debug(const QString& message) {\n";
  code += "    if (!debugEnabled) return;\n";
  code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
  code += "    QString prefix = COLOR_INFO + SYM_BULLET + \" DEBUG\" + ANSI_RESET + \": \";\n";
  code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" << prefix << message;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Displays all available commands and valid inputs\n";
  code += " * @param fsmName Name of the FSM\n";
  code += " * @param fsmDescription Description of the FSM\n";
  code += " * @param validInputs Set of valid input names\n";
  code += " * @param helpLines List of command descriptions to display\n";
  code += " */\n";
  code += "void showHelp(const QString& fsmName, const QString& fsmDescription, const QSet<QString>& validInputs, const QStringList& helpLines) {\n";
  code += "    log(DOUBLE_SEPARATOR);\n";
  code += "    log(ANSI_BOLD + COLOR_HEADER + \"Machine: \" + ANSI_RESET + COLOR_STATE + fsmName + ANSI_RESET);\n";
  code += "    if (!fsmDescription.isEmpty()) {\n";
  code += "        log(fsmDescription);\n";
  code += "    }\n";
  code += "    log(DOUBLE_SEPARATOR);\n";
  code += "    log(ANSI_BOLD + NEBULA_BLUE + \"AVAILABLE COMMANDS:\" + ANSI_RESET);\n";
  code += "    for (const QString& line : helpLines) {\n";
  code += "        log(line);\n";
  code += "    }\n";
  code += "    log(SECTION_SEPARATOR);\n";
  code += "    if (!validInputs.isEmpty()) {\n";
  code += "        log(ANSI_BOLD + STELLAR_PURPLE + \"VALID INPUTS:\" + ANSI_RESET);\n";
  code += "        QStringList sortedInputs = validInputs.values();\n";
  code += "        sortedInputs.sort();\n";
  code += "        for (const QString& input : sortedInputs) {\n";
  code += "            log(\"  \" + SPACE_TEAL + input + ANSI_RESET);\n";
  code += "        }\n";
  code += "    }\n";
  code += "    log(SECTION_SEPARATOR);\n";
  code += "}\n\n";

  return code;
}

/**
 * @brief Generate code for a transition
 * @param transition The transition
 * @param sourceState Source state
 * @param targetState Target state
 * @return Generated C++ code for the transition
 */
QString CodeGen::generateTransitionCode(Transition* transition,
                                        const State* sourceState,
                                        const State* targetState) {
  QString code;
  QString sourceName = const_cast<State*>(sourceState)->getName();
  QString targetName = const_cast<State*>(targetState)->getName();
  QString sourceLower = sourceName.toLower();
  QString targetLower = targetName.toLower();

  QString condition = transition->getCondition();
  QString event = transition->getEvent();

  int delay = transition->isDelayedTransition() ? transition->getDelay() : 0;
  bool hasCondition = !condition.isEmpty();
  bool hasEvent = !event.isEmpty();
  bool hasDelay = delay > 0 || (!transition->getDelayVariableName().isEmpty() && transition->isDelayedTransition());

  static int transitionCounter = 0;
  QString transName = sourceLower + "To" + targetName + "Transition" + QString::number(++transitionCounter);

  code += "    // Create transition: " + sourceName + " → " + targetName;
  if (hasEvent || hasCondition || hasDelay) {
    code += " (";
    if (hasEvent) {
      code += "event: " + event;
    }
    if (hasCondition) {
      if (hasEvent) code += ", ";
      code += "[ " + condition + " ]";
    }
    if (hasDelay) {
      if (hasEvent || hasCondition) code += " ";
      if (!transition->getDelayVariableName().isEmpty())
        code += "@ " + transition->getDelayVariableName();
      else
        code += "@ " + QString::number(delay) + "ms";
    }
    code += ")";
  }
  code += "\n";

  QString delayProvider;
  if (transition->isDelayedTransition() && !transition->getDelayVariableName().isEmpty()) {
    const QString varName = transition->getDelayVariableName();
    delayProvider = "[]() -> int { return " + varName + "; }";
  } else if (hasDelay) {
    delayProvider = "[]() -> int { return " + QString::number(delay) + "; }";
  } else {
    delayProvider = "[]() -> int { return 0; }";
  }

  code += "    UnifiedTransition* " + transName + " = new UnifiedTransition(";
  if (hasEvent && hasCondition) {
    code += "[]() -> bool {\n";
    code += "        return called(\"" + event + "\") && (" + condition + ");\n";
    code += "    }";
  } else if (hasEvent) {
    code += "[]() -> bool {\n";
    code += "        return called(\"" + event + "\");\n";
    code += "    }";
  } else if (hasCondition) {
    code += "[]() -> bool {\n";
    code += "        return " + condition + ";\n";
    code += "    }";
  } else {
    code += "[]() { return true; }";
  }
  code += ", " + delayProvider;
  code += ", \"" + sourceName + "\", \"" + targetName + "\"";
  code += ");\n";
  code += "    " + sourceLower + "State->addTransition(" + transName + ");\n";
  code += "    " + transName + "->setTargetState(" + targetLower + "State);\n\n";
  return code;
}

/**
 * @brief Generates a main function that uses QStateMachine
 * @param fsm FSM containing the states and transitions
 * @return Code section as QString
 */
QString CodeGen::generateQStateMachineMain(FSM* fsm) {
  QString code;

  code += "/******************************************************************************\n";
  code += " * Main function with QStateMachine\n";
  code += " ******************************************************************************/\n\n";

  State* initial = fsm->getInitialState();
  QMap<QString, State*> allStates = fsm->getStates();

  QString initialStateName = initial ? initial->getName() : "UNKNOWN";

  code += "/**\n";
  code += " * @brief Custom event for input changes\n";
  code += " */\n";
  code += "class InputEvent : public QEvent {\n";
  code += "public:\n";
  code += "    static const QEvent::Type InputChangedType = static_cast<QEvent::Type>(QEvent::User + 2);\n\n";

  code += "    InputEvent(const QString& name, const QString& value) \n";
  code += "        : QEvent(InputChangedType), m_name(name), m_value(value) {}\n\n";

  code += "    QString name() const { return m_name; }\n";
  code += "    QString value() const { return m_value; }\n\n";

  code += "private:\n";
  code += "    QString m_name;\n";
  code += "    QString m_value;\n";
  code += "};\n\n";

  code += "/**\n";
  code += " * @brief Unified transition class handling both conditions and delays\n";
  code += " */\n";
  code += "class UnifiedTransition : public QAbstractTransition {\n";
  code += "public:\n";
  code += "    /**\n";
  code += "     * @brief Constructor for a unified transition that handles both conditions and delays\n";
  code += "     * @param condition A lambda function that evaluates to a boolean\n";
  code += "     * @param delayFn A lambda function that returns the delay in milliseconds (live value)\n";
  code += "     * @param fromState Source state name (for logging)\n";
  code += "     * @param toState Target state name (for logging)\n";
  code += "     */\n";
  code += "    explicit UnifiedTransition(std::function<bool()> condition = []() { return true; },\n";
  code += "                             std::function<int()> delayFn = []() { return 0; },\n";
  code += "                             const QString& fromState = QString(),\n";
  code += "                             const QString& toState = QString())\n";
  code += "        : m_condition(std::move(condition)),\n";
  code += "          m_delayFn(std::move(delayFn)),\n";
  code += "          m_fromState(fromState),\n";
  code += "          m_toState(toState),\n";
  code += "          m_timer(new QTimer(this)),\n";
  code += "          m_conditionMet(false),\n";
  code += "          m_timerExpired(false)\n";
  code += "    {\n";
  code += "        m_timer->setSingleShot(true);\n";
  code += "        connect(m_timer, &QTimer::timeout, this, &UnifiedTransition::triggerTransition);\n";
  code += "    }\n\n";
  code += "protected:\n";
  code += "    bool eventTest(QEvent* event) override {\n";
  code += "        if (event->type() == QEvent::User + 1 && m_timerExpired) {\n";
  code += "            m_timerExpired = false;\n";
  code += "            // Re-evaluate the condition in case it changed during the delay\n";
  code += "            if (m_condition()) {\n";
  code += "                return true;\n";
  code += "            } else {\n";
  code += "                m_conditionMet = false;\n";
  code += "                cancelTimerIfActive(\"Condition is no longer met (input or variable changed).\");\n";
  code += "                return false;\n";
  code += "            }\n";
  code += "        }\n";
  code += "        try {\n";
  code += "            m_conditionMet = m_condition();\n";
  code += "            debug(\"Evaluating transition from \" + m_fromState + \" to \" + m_toState + \": \" + (m_conditionMet ? \"true\" : \"false\"));\n";
  code += "            if (!m_conditionMet) {\n";
  code += "                cancelTimerIfActive(\"Condition is no longer met (input or variable changed).\");\n";
  code += "                return false;\n";
  code += "            }\n";
  code += "            const int effDelay = m_delayFn();\n";
  code += "            if (effDelay > 0) {\n";
  code += "                if (!m_timerArmed) {\n";
  code += "                    logTransitionStart(effDelay);\n";
  code += "                    m_timer->start(effDelay);\n";
  code += "                    m_timerArmed = true;\n";
  code += "                }\n";
  code += "                return false;\n";
  code += "            }\n";
  code += "            return m_conditionMet;\n";
  code += "        } catch (const std::exception& e) {\n";
  code += "            log(\"Error evaluating transition condition: \" + QString::fromStdString(e.what()));\n";
  code += "            return false;\n";
  code += "        } catch (...) {\n";
  code += "            log(\"Unknown error evaluating transition condition\");\n";
  code += "            return false;\n";
  code += "        }\n";
  code += "    }\n\n";
  code += "    void onTransition(QEvent* event) override {\n";
  code += "        Q_UNUSED(event);\n";
  code += "        m_conditionMet = false;\n";
  code += "        m_timerArmed = false;\n";
  code += "        m_timerExpired = false;\n";
  code += "    }\n\n";
  code += "private slots:\n";
  code += "    void triggerTransition() {\n";
  code += "        if (m_condition()) {\n";
  code += "            m_timerExpired = true;\n";
  code += "            log(TIMEOUT_EXPIRED + ANSI_BOLD + SYM_TRIANGLE + \" Timeout expired\" + ANSI_RESET + \" for transition \" +\n";
  code += "                COLOR_SOURCE + m_fromState + ANSI_RESET +\n";
  code += "                COLOR_TRANSITION + \" → \" +\n";
  code += "                COLOR_TARGET + m_toState + ANSI_RESET +\n";
  code += "                ANSI_RESET + \" (delay: \" + ANSI_BOLD + QString::number(m_delayFn()) + \" ms)\" + ANSI_RESET);\n";
  code += "            QEvent* customEvent = new QEvent(static_cast<QEvent::Type>(QEvent::User + 1));\n";
  code += "            machine()->postEvent(customEvent);\n";
  code += "        } else {\n";
  code += "            m_conditionMet = false;\n";
  code += "            cancelTimerIfActive(\"Condition became false before timeout expired.\");\n";
  code += "            debug(\"Condition no longer valid after delay for transition \" +\n";
  code += "                  m_fromState + \" → \" + m_toState +\n";
  code += "                  \", not triggering\");\n";
  code += "        }\n";
  code += "    }\n\n";
  code += "private:\n";
  code += "    void cancelTimerIfActive(const QString& reason = QString()) {\n";
  code += "        if (m_timer && m_timer->isActive()) {\n";
  code += "            QString msg = \"Cancelling timer for transition \" + m_fromState + \" → \" + m_toState;\n";
  code += "            if (!reason.isEmpty()) {\n";
  code += "                msg += \": \" + reason;\n";
  code += "            }\n";
  code += "            log(msg);\n";
  code += "            m_timer->stop();\n";
  code += "            m_timerArmed = false;\n";
  code += "        }\n";
  code += "    }\n\n";
  code += "    void logTransitionStart(int effDelay) {\n";
  code += "        log(TIMEOUT_STARTED + ANSI_BOLD + SYM_TRIANGLE + \" Timeout started\" + ANSI_RESET + \" for transition \" +\n";
  code += "            COLOR_SOURCE + m_fromState + ANSI_RESET +\n";
  code += "            COLOR_TRANSITION + \" → \" +\n";
  code += "            COLOR_TARGET + m_toState + ANSI_RESET +\n";
  code += "            ANSI_RESET + \" (delay: \" + ANSI_BOLD + QString::number(effDelay) + \" ms)\" + ANSI_RESET);\n";
  code += "        debug(\"Condition met for transition \" +\n";
  code += "              COSMIC_DUST + m_fromState + ANSI_RESET + \" \" + SYM_ARROW + \" \" +\n";
  code += "              QUANTUM_GREEN + m_toState + ANSI_RESET +\n";
  code += "              \", starting \" + STARDUST + QString::number(effDelay) + \"ms\" + ANSI_RESET + \" delay timer\");\n";
  code += "    }\n\n";
  code += "    std::function<bool()> m_condition;\n";
  code += "    std::function<int()> m_delayFn;\n";
  code += "    QString m_fromState;\n";
  code += "    QString m_toState;\n";
  code += "    QTimer* m_timer;\n";
  code += "    bool m_conditionMet;\n";
  code += "    bool m_timerArmed = false;\n";
  code += "    bool m_timerExpired = false;\n";
  code += "};\n\n";

  code += "/**\n";
  code += " * @brief Main function that uses QStateMachine for state management\n";
  code += " */\n";
  code += "int main(int argc, char *argv[]) {\n";
  code += "    QCoreApplication app(argc, argv);\n";
  code += "    \n";
  code += "    qDebug().noquote() << \"\\n\" + DOUBLE_SEPARATOR;\n";
  code += "    qDebug().noquote() << ANSI_BOLD + COLOR_HEADER + SYM_STAR + \" \" + SYM_STAR + \" \" + SYM_STAR + \"  OBLIVION STATE MACHINE  \" + SYM_STAR + \" \" + SYM_STAR + \" \" + SYM_STAR + ANSI_RESET;\n";
  code += "    qDebug().noquote() << COLOR_TRANSITION + \"     Navigating the infinite expanse of software states\" + ANSI_RESET;\n";
  code += "    qDebug().noquote() << DOUBLE_SEPARATOR + \"\\n\";\n";
  code += "    \n";
  code += "    debug(\"Starting FSM application with QStateMachine\");\n";
  code += "    debug(\"State machine name: \" + ANSI_BOLD + COLOR_STATE + \"" + fsm->getName() + "\" + ANSI_RESET);\n";

  code += "    std::signal(SIGINT, [](int) {\n";
  code += "        qDebug().noquote() << \"\";\n";
  code += "        debug(ANSI_BOLD + COLOR_ERROR + \"Interrupt received. Exiting gracefully...\" + ANSI_RESET);\n";
  code += "        QCoreApplication::quit();\n";
  code += "    });\n\n";

  QSet<QString> inputNames = fsm->getInputs();
  QSet<QString> outputNames = fsm->getOutputs();

  code += "    // Initialize inputs and outputs\n";
  for (const QString& input : inputNames) {
    code += "    inputs[QStringLiteral(\"" + input.trimmed() + "\")] = QString();\n";
    code += "    getEventFlags()[QStringLiteral(\"" + input.trimmed() + "\")] = false;\n";
  }

  for (const QString& output : outputNames) {
    code += "    outputs[QStringLiteral(\"" + output.trimmed() + "\")] = QString();\n";
  }
  code += "\n";

  code += "    QSet<QString> validInputNames;\n";
  for (const QString& input : inputNames) {
    code += "    validInputNames.insert(QStringLiteral(\"" + input.trimmed() + "\"));\n";
  }
  code += "\n";

  code += "    const QStringList helpLines = {\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"input_name=value\").leftJustified(26) + ANSI_RESET + \"- Set an input value\",\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"input_name\").leftJustified(26) + ANSI_RESET + \"- Call an input\",\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"/status\").leftJustified(26) + ANSI_RESET + \"- Show the current system state\",\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"/help\").leftJustified(26) + ANSI_RESET + \"- Show this help message\",\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"/quit /exit\").leftJustified(26) + ANSI_RESET + \"- Exit the application\",\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"/debugon /debugoff\").leftJustified(26) + ANSI_RESET + \"- Turn debug statements on/off\"\n";
  code += "    };\n\n";

  code += "    fsm.setObjectName(\"" + fsm->getName() + "\");\n\n";
  code += "    fsm.setProperty(\"description\", \"" + fsm->getComment() + "\");\n\n";

  code += "    debug(\"Creating states...\");\n";

  for (auto it = allStates.begin(); it != allStates.end(); ++it) {
    State* state = it.value();
    QString stateName = state->getName();
    QString stateLower = stateName.toLower();

    code += "    QState* " + stateLower + "State = new QState(&fsm);\n";
    code += "    " + stateLower + "State->setObjectName(\"" + stateName + "\");\n";
    code += "    debug(\"  Created state: \" + COLOR_STATE + \"" + stateName + "\" + ANSI_RESET);\n";

    QString onEntry = state->getCode();
    if (!onEntry.isEmpty()) {
      code += "    QObject::connect(" + stateLower + "State, &QState::entered, []() {\n";
      code += "        log(DOUBLE_SEPARATOR);\n";
      code += "        log(STATE_HEADER + ANSI_BOLD + COLOR_STATE + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
      code += "        log(SECTION_SEPARATOR);\n";
      code += "        log(\"Executing onEntry action for state: \" + ANSI_BOLD + \"" + stateName + "\" + ANSI_RESET);\n";
      code += "        " + onEntry + "\n";
      code += "        log(SECTION_SEPARATOR);\n";
      code += "    });\n";
    } else {
      code += "    QObject::connect(" + stateLower + "State, &QState::entered, []() {\n";
      code += "        log(DOUBLE_SEPARATOR);\n";
      code += "        log(STATE_HEADER + ANSI_BOLD + COLOR_STATE + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
      code += "        log(SECTION_SEPARATOR);\n";
      code += "    });\n";
    }
    code += "\n";
  }

  code += "    fsm.setInitialState(" + initialStateName.toLower() + "State);\n";
  code += "    debug(\"Initial state set to \" + ANSI_BOLD + COLOR_TARGET + \"" + initialStateName + "\" + ANSI_RESET);\n\n";

  code += "    debug(\"Setting up transitions...\");\n";

  for (auto stateIt = allStates.begin(); stateIt != allStates.end(); ++stateIt) {
    State* sourceState = stateIt.value();
    QString sourceName = sourceState->getName();

    QList<Transition*> transitions = fsm->getTransitionsFrom(sourceState);

    for (Transition* transition : transitions) {
      State* targetState = transition->getTo();
      if (!targetState) continue;

      QString targetName = targetState->getName();

      code += generateTransitionCode(transition, sourceState, targetState);
    }
  }

  code += "    showHelp(fsm.objectName(), fsm.property(\"description\").toString(), validInputNames, helpLines);\n";
  code += "    qDebug().noquote() << \"\";\n\n";

  code += "    FILE* terminalInput = fdopen(dup(STDIN_FILENO), \"r\");\n";
  code += "    if (!terminalInput) {\n";
  code += "        debug(\"Error: Could not open terminal input\");\n";
  code += "        return 1;\n";
  code += "    }\n\n";

  code += "    int terminalFd = fileno(terminalInput);\n";
  code += "    QSocketNotifier* inputNotifier = new QSocketNotifier(terminalFd, QSocketNotifier::Read);\n\n";

  code += "    QObject::connect(inputNotifier, &QSocketNotifier::activated, [&]() {\n";
  code += "        char buffer[256];\n";
  code += "        if (fgets(buffer, sizeof(buffer), terminalInput)) {\n";
  code += "            QString inputLine = QString::fromLocal8Bit(buffer).trimmed();\n";
  code += "            \n";
  code += "            if (inputLine.isEmpty()) return;\n";
  code += "            \n";
  code += "            if (inputLine == \"/quit\" || inputLine == \"/exit\") {\n";
  code += "                log(\"Exit command received. Terminating application.\");\n";
  code += "                QCoreApplication::quit();\n";
  code += "                return;\n";
  code += "            }\n";
  code += "            \n";
  code += "            if (inputLine == \"/help\") {\n";
  code += "                showHelp(fsm.objectName(), fsm.property(\"description\").toString(), validInputNames, helpLines);\n";
  code += "                return;\n";
  code += "            }\n";
  code += "            \n";
  code += "            if (inputLine == \"/status\") {\n";
  code += "                QString currentState = fsm.configuration().isEmpty() ? \"UNKNOWN\" : (*fsm.configuration().begin())->objectName();\n";
  code += "                log(\"Current state: \" + ANSI_BOLD + COLOR_STATE + currentState + ANSI_RESET);\n";
  code += "                return;\n";
  code += "            }\n";
  code += "            \n";
  code += "            if (inputLine == \"/debugon\") {\n";
  code += "                debugEnabled = true;\n";
  code += "                log(\"Debug output enabled.\");\n";
  code += "                return;\n";
  code += "            }\n";
  code += "            if (inputLine == \"/debugoff\") {\n";
  code += "                debugEnabled = false;\n";
  code += "                log(\"Debug output disabled.\");\n";
  code += "                return;\n";
  code += "            }\n";
  code += "            \n";
  code += "            QRegularExpression inputRegex(\"^(\\\\w+)(?:=(.*))?$\");\n";
  code += "            QRegularExpressionMatch match = inputRegex.match(inputLine);\n";
  code += "            \n";
  code += "            if (match.hasMatch()) {\n";
  code += "                QString name = match.captured(1);\n";
  code += "                QString value = match.captured(2);\n";
  code += "                \n";
  code += "                if (!validInputNames.contains(name)) {\n";
  code += "                    log(\"Invalid input name: \" + ANSI_BOLD + WARP_RED + name + ANSI_RESET);\n";
  code += "                    return;\n";
  code += "                }\n";
  code += "                \n";
  code += "                if (!value.isEmpty()) {\n";
  code += "                    // SET mode: store the new value and trigger event\n";
  code += "                    debug(\"[DEBUG] SET MODE for '\" + name + \"' with value '\" + value + \"'\");\n";
  code += "                    inputs[name] = value;\n";
  code += "                    logInputEvent(name, value);\n";
  code += "                    setInputCalled(name);\n";
  code += "                    fsm.postEvent(new InputEvent(name, value));\n";
  code += "                } else {\n";
  code += "                    // CALL mode: treat as pure event without changing stored value\n";
  code += "                    QString lastValue = inputs.contains(name) ? inputs[name] : QString();\n";
  code += "                    logInputEvent(name, lastValue);\n";
  code += "                    setInputCalled(name);\n";
  code += "                    fsm.postEvent(new InputEvent(name, lastValue));\n";
  code += "                }\n";
  code += "            } else {\n";
  code += "                log(\"Unrecognized command: \" + ANSI_BOLD + WARP_RED + inputLine + ANSI_RESET);\n";
  code += "            }\n";
  code += "        }\n";
  code += "    });\n\n";

  code += "    debug(ANSI_BOLD + COLOR_HEADER + \"INITIALIZING STATE MACHINE\" + ANSI_RESET);\n";
  code += "    fsm.start();\n";
  code += "    debug(COLOR_SUCCESS + SYM_SUCCESS + \" Transition engine activated successfully\" + ANSI_RESET);\n";
  code += "    qDebug().noquote() << \"\";\n\n";

  code += "    QObject::connect(&app, &QCoreApplication::aboutToQuit, [terminalInput]() {\n";
  code += "        if (terminalInput) {\n";
  code += "            fclose(terminalInput);\n";
  code += "        }\n";
  code += "    });\n\n";

  code += "    int result = app.exec();\n";
  code += "    debug(\"Application terminated with code \" + QString::number(result));\n";
  code += "    return result;\n";
  code += "}\n";

  return code;
}
