#include "CodeGen.hpp"
#include "fsm.hpp"
#include "state.hpp"
#include "transition.hpp"
#include "variable.hpp"
#include <QDebug>
#include <QRegularExpression>
#include <csignal>

/**
 * @brief Constructor for the CodeGen class
 * @param parent The parent QObject
 */
CodeGen::CodeGen(QObject *parent) : QObject(parent)
{
}

/**
 * @brief Top-level entry for generating code from an FSM
 * @param fsm The state machine to generate code from
 * @return Generated C++ code as a QString
 */
QString CodeGen::generateCode(FSM *fsm)
{
    QString code;

    code += "/**\n";
    code += " * Generated Finite State Machine: " + fsm->getName() + "\n";
    
    QString description = fsm->getComment();
    if (!description.isEmpty()) {
        code += " * Description: " + description + "\n";
    }
    
    code += " * \n";
    code += " * This file was automatically generated by ICP FSM Code Generator\n";
    code += " */\n\n";

    code += generateHeaders();
    code += generateVariableDeclarations(fsm);
    code += generateRuntimeMonitoring();
    code += generateHelperFunctions();
    code += generateQStateMachineMain(fsm);

    return code;
}

/**
 * @brief Generates standard C++ header includes
 * @return Code section as QString
 */
QString CodeGen::generateHeaders()
{
    QString code;
    
    code += "#include <QtCore/QDebug>\n";
    code += "#include <QtCore/QString>\n";
    code += "#include <QtCore/QMap>\n";
    code += "#include <QtCore/QDateTime>\n";
    code += "#include <QtCore/QCoreApplication>\n";
    code += "#include <QtCore/QTimer>\n";
    code += "#include <QtCore/QSocketNotifier>\n";
    code += "#include <QtCore/QStateMachine>\n";
    code += "#include <QtCore/QState>\n";
    code += "#include <QtCore/QEvent>\n";
    code += "#include <QtCore/QAbstractTransition>\n";
    code += "#include <QtCore/QRegularExpression>\n";
    code += "#include <stdio.h>\n";
    code += "#include <unistd.h>\n";
    code += "#include <csignal>\n";
    code += "\n";
    
    return code;
}

/**
 * @brief Provides basic helpers for managing input/output values
 * @return Code section as QString
 */
QString CodeGen::generateHelperFunctions()
{
    QString code;
    
    code += "/******************************************************************************\n";
    code += " * Utility functions for input/output and value handling\n";
    code += " ******************************************************************************/\n\n";
    
    code += "/**\n";
    code += " * @brief Gets the string value of an input\n";
    code += " * @param input Input name\n";
    code += " * @return Current string value of the input, or empty string if not found\n";
    code += " */\n";
    code += "QString valueof(const QString &input) {\n";
    code += "    if (inputs.contains(input)) {\n";
    code += "        return inputs[input];\n";
    code += "    }\n";
    code += "    return QString();\n";
    code += "}\n\n";
    
    code += "/**\n";
    code += " * @brief Safely converts a string to an integer\n";
    code += " * @param str String to convert\n";
    code += " * @return Integer value, or 0 if conversion fails\n";
    code += " */\n";
    code += "int atoi_safe(const QString &str) {\n";
    code += "    bool ok = false;\n";
    code += "    int value = str.toInt(&ok);\n";
    code += "    return ok ? value : 0;\n";
    code += "}\n\n";
    
    code += "/**\n";
    code += " * @brief Direct replacement for C's atoi that handles QString inputs\n";
    code += " * @param str String to convert\n";
    code += " * @return Integer value or 0 if conversion fails\n";
    code += " */\n";
    code += "int atoi(const QString &str) {\n";
    code += "    return atoi_safe(str);\n";
    code += "}\n\n";
    
    code += "/**\n";
    code += " * @brief Checks if an input is defined and has a non-empty value\n";
    code += " * @param input Input name to check\n";
    code += " * @return True if the input exists and has a value\n";
    code += " */\n";
    code += "bool defined(const QString &input) {\n";
    code += "    return inputs.contains(input) && !inputs[input].isEmpty();\n";
    code += "}\n\n";
    
    code += "/**\n";
    code += " * @brief Sends an output value to a specific port\n";
    code += " * @param port Output port name\n";
    code += " * @param value Integer value to send\n";
    code += " */\n";
    code += "void output(const QString &port, int value) {\n";
    code += "    outputs[port] = QString::number(value);\n";
    code += "    logOutputEvent(port, QString::number(value));\n";
    code += "}\n\n";
    
    code += "/**\n";
    code += " * @brief Returns time elapsed since state entry in milliseconds\n";
    code += " * @return Milliseconds elapsed since entering the current state\n";
    code += " */\n";
    code += "int elapsed() {\n";
    code += "    static qint64 stateEntryTime = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    static QState* lastState = nullptr;\n";
    code += "    \n";
    code += "    QState* currentState = fsm.configuration().isEmpty() ? nullptr : \n";
    code += "        static_cast<QState*>(*fsm.configuration().begin());\n";
    code += "    \n";
    code += "    if (currentState != lastState) {\n";
    code += "        stateEntryTime = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "        lastState = currentState;\n";
    code += "    }\n";
    code += "    \n";
    code += "    return QDateTime::currentDateTime().toMSecsSinceEpoch() - stateEntryTime;\n";
    code += "}\n\n";

    code += "// Shared event flags for tracking input calls\n";
    code += "QMap<QString, bool>& getEventFlags() {\n";
    code += "    static QMap<QString, bool>* flags = new QMap<QString, bool>();\n";
    code += "    return *flags;\n";
    code += "}\n\n";

    code += "/**\n";
    code += " * @brief Checks if an input was called as an event (regardless of value)\n";
    code += " * @param input Input name to check\n";
    code += " * @return True if the input was triggered as an event\n";
    code += " */\n";
    code += "bool called(const QString &input) {\n";
    code += "    // Access shared event flags\n";
    code += "    QMap<QString, bool>& eventFlags = getEventFlags();\n";
    code += "    \n";
    code += "    bool result = eventFlags.value(input, false);\n";
    code += "    debugPrint(\"called('\" + input + \"') returning \" + (result ? \"true\" : \"false\"),4);\n";
    code += "    eventFlags[input] = false;  // Reset after checking (one-shot events)\n";
    code += "    return result;\n";
    code += "}\n\n";

    code += "/**\n";
    code += " * @brief Sets the trigger flag for an input\n";
    code += " * @param input Input name to mark as called\n";
    code += " */\n";
    code += "void setInputCalled(const QString &input) {\n";
    code += "    // Access the same shared event flags\n";
    code += "    QMap<QString, bool>& eventFlags = getEventFlags();\n";
    code += "    eventFlags[input] = true;\n";
    code += "}\n\n";

    return code;
}

/**
 * @brief Generates global declarations for standard and custom FSM variables
 * @param fsm State machine containing variable definitions
 * @return Code section as QString
 */
QString CodeGen::generateVariableDeclarations(FSM *fsm)
{
    QString code;
    
    code += "/******************************************************************************\n";
    code += " * Variable declarations\n";
    code += " ******************************************************************************/\n\n";
    
    code += "QStateMachine fsm;            // Global state machine instance\n";
    code += "QMap<QString, QString> inputs;      // Map of input names to values\n";
    code += "QMap<QString, QString> outputs;     // Map of output names to values\n\n";
    
    QMap<QString, Variable*> variables = fsm->getVariables();
    if (!variables.isEmpty()) {
        code += "// Custom variables for " + fsm->getName() + "\n";
        
        for (auto it = variables.constBegin(); it != variables.constEnd(); ++it) {
            Variable* var = it.value();
            code += var->getType() + " " + var->getName() + " = " + var->getValue().toString() + ";\n";
        }
        code += "\n";
    }
    
    return code;
}

/**
 * @brief Provides logging functions for state transitions, events, and diagnostics
 * @return Code section as QString
 */
QString CodeGen::generateRuntimeMonitoring()
{
    QString code;
    
    code += "/******************************************************************************\n";
    code += " * Runtime monitoring and debugging\n";
    code += " ******************************************************************************/\n\n";

    code += "// ANSI basic formatting codes\n";
    code += "const QString ANSI_RESET = \"\\033[0m\";\n";
    code += "const QString ANSI_BOLD = \"\\033[1m\";\n";
    code += "\n";
    
    code += "// Color constants for console output\n";
    code += "const QString COSMIC_PURPLE = \"\\033[38;5;93m\";    // Rich cosmic purple, used for state names & headers\n";
    code += "const QString NEBULA_BLUE = \"\\033[38;5;39m\";      // Bright nebula blue, used for transition info and info level logs\n";
    code += "const QString SPACE_TEAL = \"\\033[38;5;31m\";       // Deep space teal, used for input values\n";
    code += "const QString NEBULA_PINK = \"\\033[38;5;169m\";     // Bright nebula pink, used for output values\n";
    code += "const QString STARDUST = \"\\033[38;5;153m\";        // Light blue stardust, used for variable values\n";
    code += "const QString STAR_WHITE = \"\\033[38;5;231m\";      // Bright star white, used for command headers\n";
    code += "const QString COSMIC_DUST = \"\\033[38;5;102m\";     // Faded cosmic dust, used for source states and notice level logs\n\n";
    
    code += "// Accent colors - for special highlights and alerts\n";
    code += "const QString STELLAR_PURPLE = \"\\033[38;5;141m\";  // Bright stellar purple, used for section headers\n";
    code += "const QString PULSAR_YELLOW = \"\\033[38;5;220m\";   // Pulsating yellow, used for warnings\n";
    code += "const QString QUANTUM_GREEN = \"\\033[38;5;84m\";    // Quantum field green, used for target states and success messages\n";
    code += "const QString WARP_RED = \"\\033[38;5;196m\";        // Warp field red, used for error messages\n\n";

    code += "// Semantic color mappings - function-based color assignments\n";
    code += "const QString COLOR_STATE = COSMIC_PURPLE;        // State names & headers\n";
    code += "const QString COLOR_TRANSITION = NEBULA_BLUE;     // Transition information\n";
    code += "const QString COLOR_SOURCE = COSMIC_DUST;         // Source states\n";
    code += "const QString COLOR_TARGET = QUANTUM_GREEN;       // Target states\n";
    code += "const QString COLOR_INPUT = SPACE_TEAL;           // Input values\n";
    code += "const QString COLOR_OUTPUT = NEBULA_PINK;         // Output values\n";
    code += "const QString COLOR_COMMAND = STAR_WHITE;         // Command headers\n";
    code += "const QString COLOR_VALUE = STARDUST;             // Variable values\n";
    code += "const QString COLOR_INFO = NEBULA_BLUE;           // Info level logs\n";
    code += "const QString COLOR_NOTICE = COSMIC_DUST;         // Notice level logs\n";
    code += "const QString COLOR_WARNING = PULSAR_YELLOW;      // Warning level logs\n";
    code += "const QString COLOR_ERROR = WARP_RED;             // Error level logs\n";
    code += "const QString COLOR_SUCCESS = QUANTUM_GREEN;      // Success messages\n";
    code += "const QString COLOR_HEADER = STELLAR_PURPLE;      // Section headers\n\n";

    code += "// Symbols for marking elements\n";
    code += "const QString SYM_BULLET = \"•\";       // Primary bullet point\n";
    code += "const QString SYM_BULLET_2 = \"◦\";     // Secondary bullet point\n";
    code += "const QString SYM_STAR = \"✧\";         // Star/asterisk \n";
    code += "const QString SYM_TRIANGLE = \"▶\";     // Triangle pointer\n";
    code += "const QString SYM_ARROW = \"→\";        // Right arrow\n";
    code += "const QString SYM_SUCCESS = \"✓\";      // Success checkmark\n";
    code += "const QString SYM_ERROR = \"✗\";        // Error symbol\n\n";

    code += "// Formatted UI strings for console output\n";
    code += "const QString STATE_HEADER = ANSI_BOLD + COLOR_STATE + \"════════ STATE: \" + ANSI_RESET;\n";
    code += "const QString COMMAND_HEADER = ANSI_BOLD + COLOR_COMMAND + \"⟫ COMMAND: \" + ANSI_RESET;\n";
    code += "const QString SECTION_SEPARATOR = COLOR_NOTICE + \"───────────────────────────────────────────────────\" + ANSI_RESET;\n";
    code += "const QString DOUBLE_SEPARATOR = COLOR_TRANSITION + \"═══════════════════════════════════════════════════\" + ANSI_RESET;\n\n";

    code += "/**\n";
    code += " * @brief Logs state transitions for monitoring\n";
    code += " * @param fromState Source state name\n";
    code += " * @param toState Target state name\n";
    code += " */\n";
    code += "void logStateChange(const QString& fromState, const QString& toState) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"\";\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" \n";
    code += "             << ANSI_BOLD + COLOR_TRANSITION + \"STATE CHANGE\" + ANSI_RESET + \": \"\n";
    code += "             << COLOR_SOURCE + fromState + ANSI_RESET \n";
    code += "             << \" \" + SYM_ARROW + \" \" \n";
    code += "             << ANSI_BOLD + COLOR_TARGET + toState + ANSI_RESET;\n";
    code += "}\n\n";
    
    code += "/**\n";
    code += " * @brief Logs input values for monitoring\n";
    code += " * @param input Input name\n";
    code += " * @param value Input value\n";
    code += " */\n";
    code += "void logInputEvent(const QString& input, const QString& value) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\"\n";
    code += "             << COLOR_INPUT + SYM_BULLET + \" INPUT\" + ANSI_RESET + \": \"\n";
    code += "             << \"  \" + ANSI_BOLD + input + ANSI_RESET \n";
    code += "             << \" = \" \n";
    code += "             << COLOR_VALUE + value + ANSI_RESET;\n";
    code += "}\n\n";
    
    code += "/**\n";
    code += " * @brief Logs output values for monitoring\n";
    code += " * @param output Output name\n";
    code += " * @param value Output value\n";
    code += " */\n";
    code += "void logOutputEvent(const QString& output, const QString& value) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\"\n";
    code += "             << COLOR_OUTPUT + SYM_BULLET + \" OUT \" + ANSI_RESET + \": \"\n";
    code += "             << \"\" + ANSI_BOLD + output + ANSI_RESET \n";
    code += "             << \"=\" \n";
    code += "             << COLOR_VALUE + value + ANSI_RESET;\n";
    code += "}\n\n";
    
    code += "/**\n";
    code += " * @brief Prints a debug message with timestamp\n";
    code += " * @param message Debug message to display\n";
    code += " * @param level Debug level (0=INFO, 1=NOTICE, 2=WARNING, 3=ERROR)\n";
    code += " */\n";
    code += "void debugPrint(const QString& message, int level = 0) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    QString prefix;\n";
    code += "    switch (level) {\n";
    code += "        case 0: prefix = COLOR_INFO + SYM_BULLET + \" INFO\" + ANSI_RESET + \": \"; break;\n";
    code += "        case 1: prefix = COLOR_NOTICE + SYM_BULLET + \" NOTICE\" + ANSI_RESET + \": \"; break;\n";
    code += "        case 2: prefix = COLOR_WARNING + SYM_TRIANGLE + \" WARNING\" + ANSI_RESET + \": \"; break;\n";
    code += "        case 3: prefix = COLOR_ERROR + SYM_ERROR + \" ERROR\" + ANSI_RESET + \": \"; break;\n";
    code += "        default: prefix = \"DEBUG: \";\n";
    code += "    }\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" << prefix << message;\n";
    code += "}\n\n";

    code += "/**\n";
    code += " * @brief Displays all available commands and valid inputs in a formatted way\n";
    code += " * @param validInputs Set of valid input names for this state machine\n";
    code += " * @param helpLines List of command descriptions to display\n";
    code += " */\n";
    code += "void showHelp(const QSet<QString>& validInputs, const QStringList& helpLines) {\n";
    code += "    qint64 timeMs = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "    qDebug().noquote() << \"[\" << timeMs << \"]\" << ANSI_BOLD + NEBULA_BLUE + \"AVAILABLE COMMANDS\" + ANSI_RESET;\n";
    code += "    qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "    \n";
    code += "    for (const QString& line : helpLines) {\n";
    code += "        qDebug().noquote() << line;\n";
    code += "    }\n";
    code += "    \n";
    code += "    if (!validInputs.isEmpty()) {\n";
    code += "        qDebug().noquote() << \"\\n\" + ANSI_BOLD + STELLAR_PURPLE + \"VALID INPUTS:\" + ANSI_RESET;\n";
    code += "        \n";
    code += "        QStringList sortedInputs = validInputs.values();\n";
    code += "        sortedInputs.sort();\n";
    code += "        \n";
    code += "        for (const QString& input : sortedInputs) {\n";
    code += "            qDebug().noquote() << \"  \" + SPACE_TEAL + input + ANSI_RESET;\n";
    code += "        }\n";
    code += "    }\n";
    code += "    \n";
    code += "    qDebug().noquote() << SECTION_SEPARATOR;\n";
    code += "}\n\n";

    return code;
}

/**
 * @brief Generate code for a transition
 * @param transition The transition
 * @param sourceState Source state
 * @param targetState Target state
 * @return Generated C++ code for the transition
 */
QString CodeGen::generateTransitionCode(Transition *transition, 
                                     const State *sourceState, 
                                     const State *targetState) {
    QString code;
    QString sourceName = const_cast<State*>(sourceState)->getName();
    QString targetName = const_cast<State*>(targetState)->getName();
    QString sourceLower = sourceName.toLower();
    QString targetLower = targetName.toLower();
    
    QString condition = transition->getCondition();
    condition = condition.replace("atoi(", "atoi_safe(");
    
    int delay = transition->isDelayedTransition() ? transition->getDelay() : 0;
    bool hasCondition = !condition.isEmpty();
    bool hasDelay = delay > 0;
    
    static int transitionCounter = 0;
    QString transName = sourceLower + "To" + targetName + "Transition" + QString::number(++transitionCounter);
    
    // For self-transitions (same source and target), add protection against infinite loops
    QString eventName = transition->getEvent().trimmed();
    if (sourceState == targetState && !eventName.isEmpty()) {
        // Only generate a self-transition that requires the specific event
        if (!condition.isEmpty()) {
            condition = "called(\"" + eventName + "\") && (" + condition + ")";
        } else {
            condition = "called(\"" + eventName + "\")";
        }
        hasCondition = true;
    }

    code += "    // Create transition: " + sourceName + " → " + targetName;
    
    if (hasCondition || hasDelay) {
        code += " (";
        if (hasCondition) {
            code += "[ " + condition + " ]";
        }
        if (hasDelay) {
            if (hasCondition) code += " ";
            code += "@ " + QString::number(delay) + "ms";
        }
        code += ")";
    }
    code += "\n";
    
    code += "    UnifiedTransition* " + transName + " = new UnifiedTransition(";
    
    if (hasCondition) {
        code += "[]() -> bool {\n";
        code += "        return " + condition + ";\n";
        code += "    }";
    } else {
        code += "[]() { return true; }"; 
    }
    
    code += ", " + QString::number(delay);
    code += ", \"" + sourceName + "\", \"" + targetName + "\"";
    
    if (hasCondition) {
        code += ", \"" + condition.replace("\"", "\\\"") + "\"";
    }
    
    code += ");\n";
    
    code += "    " + sourceLower + "State->addTransition(" + transName + ");\n";
    code += "    " + transName + "->setTargetState(" + targetLower + "State);\n\n";
    
    return code;
}

/**
 * @brief Generates a main function that uses QStateMachine
 * @param fsm FSM containing the states and transitions
 * @return Code section as QString
 */
QString CodeGen::generateQStateMachineMain(FSM *fsm)
{
    QString code;
    
    code += "/******************************************************************************\n";
    code += " * Main function with QStateMachine\n";
    code += " ******************************************************************************/\n\n";

    State *initial = fsm->getInitialState();
    QMap<QString, State*> allStates = fsm->getStates();
    
    QString initialStateName = initial ? initial->getName() : "UNKNOWN";

    code += "/**\n";
    code += " * @brief Custom event for input changes\n";
    code += " */\n";
    code += "class InputEvent : public QEvent {\n";
    code += "public:\n";
    code += "    static const QEvent::Type InputChangedType = static_cast<QEvent::Type>(QEvent::User + 2);\n\n";
    
    code += "    InputEvent(const QString& name, const QString& value, bool isCallMode = false) \n";
    code += "        : QEvent(InputChangedType), m_name(name), m_value(value), m_isCallMode(isCallMode) {}\n\n";
    
    code += "    QString name() const { return m_name; }\n";
    code += "    QString value() const { return m_value; }\n";
    code += "    bool isCallMode() const { return m_isCallMode; }\n\n";
    
    code += "private:\n";
    code += "    QString m_name;\n";
    code += "    QString m_value;\n";
    code += "    bool m_isCallMode;  // True if this was a pure event call without value assignment\n";
    code += "};\n\n";

    code += "/**\n";
    code += " * @brief Unified transition class handling both conditions and delays\n";
    code += " */\n";
    code += "class UnifiedTransition : public QAbstractTransition {\n";
    code += "public:\n";
    code += "    /**\n";
    code += "     * @brief Constructor for a unified transition that handles both conditions and delays\n";
    code += "     * @param condition A lambda function that evaluates to a boolean\n";
    code += "     * @param delayMs Delay in milliseconds before triggering the transition (0 = no delay)\n";
    code += "     * @param fromState Source state name (for logging)\n";
    code += "     * @param toState Target state name (for logging)\n";
    code += "     * @param conditionStr String representation of the condition (for logging)\n";
    code += "     */\n";
    code += "    explicit UnifiedTransition(std::function<bool()> condition = []() { return true; },\n";
    code += "                             int delayMs = 0,\n";
    code += "                             const QString& fromState = QString(),\n";
    code += "                             const QString& toState = QString(),\n";
    code += "                             const QString& conditionStr = QString())\n";
    code += "        : m_condition(std::move(condition)),\n";
    code += "          m_delay(delayMs),\n";
    code += "          m_fromState(fromState),\n";
    code += "          m_toState(toState),\n";
    code += "          m_conditionStr(conditionStr),\n";
    code += "          m_timer(nullptr),\n";
    code += "          m_conditionMet(false)\n";
    code += "    {\n";
    code += "        if (m_delay > 0) {\n";
    code += "            m_timer = new QTimer(this);\n";
    code += "            m_timer->setSingleShot(true);\n";
    code += "            connect(m_timer, &QTimer::timeout, this, &UnifiedTransition::triggerTransition);\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "protected:\n";
    code += "    /**\n";
    code += "     * @brief Tests whether the transition should be triggered\n";
    code += "     * @param event The event triggering the transition\n";
    code += "     * @return True if the transition should occur, false otherwise\n";
    code += "     */\n";
    code += "    bool eventTest(QEvent* event) override {\n";
    code += "        if (event->type() == QEvent::User + 1 && m_conditionMet) {\n";
    code += "            return true;\n";
    code += "        }\n";
    code += "        \n";
    code += "        // Process input events to track what was called\n";
    code += "        if (event->type() == InputEvent::InputChangedType) {\n";
    code += "            InputEvent* inputEvent = static_cast<InputEvent*>(event);\n";
    code += "            // Mark this input as having been called\n";
    code += "            setInputCalled(inputEvent->name());\n";
    code += "        }\n";
    code += "        \n";
    code += "        // Always re-evaluate the condition when any event occurs\n";
    code += "        try {\n";
    code += "            m_conditionMet = m_condition();\n";
    code += "            debugPrint(\"Evaluating transition from \" + m_fromState + \" to \" + m_toState + \": \" + (m_conditionMet ? \"true\" : \"false\"), 4);\n";
    code += "            \n";
    code += "            if (!m_conditionMet) {\n";
    code += "                cancelTimerIfActive();\n";
    code += "                return false;\n";
    code += "            }\n";
    code += "            \n";
    code += "            if (m_delay > 0) {\n";
    code += "                if (m_timer && !m_timer->isActive()) {\n";
    code += "                    logTransitionStart();\n";
    code += "                    m_timer->start(m_delay);\n";
    code += "                }\n";
    code += "                return false;\n";
    code += "            }\n";
    code += "            \n";
    code += "            return m_conditionMet;\n";
    code += "        } catch (const std::exception& e) {\n";
    code += "            debugPrint(\"Error evaluating transition condition: \" + QString::fromStdString(e.what()), 3);\n";
    code += "            return false;\n";
    code += "        } catch (...) {\n";
    code += "            debugPrint(\"Unknown error evaluating transition condition\", 3);\n";
    code += "            return false;\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "    /**\n";
    code += "     * @brief Logs the transition when it occurs\n";
    code += "     * @param event The event triggering the transition\n";
    code += "     */\n";
    code += "    void onTransition(QEvent* event) override {\n";
    code += "        Q_UNUSED(event);\n";
    code += "        \n";
    code += "        debugPrint(DOUBLE_SEPARATOR);\n";
    code += "        debugPrint(\"Transition: \" + \n";
    code += "                  ANSI_BOLD + COSMIC_DUST + m_fromState + ANSI_RESET + \n";
    code += "                  \" \" + SYM_ARROW + \" \" + \n";
    code += "                  ANSI_BOLD + QUANTUM_GREEN + m_toState + ANSI_RESET);\n";
    code += "        \n";
    code += "        if (!m_conditionStr.isEmpty()) {\n";
    code += "            debugPrint(\"  Condition satisfied: \" + COLOR_NOTICE + m_conditionStr + ANSI_RESET);\n";
    code += "        }\n";
    code += "        \n";
    code += "        if (m_delay > 0) {\n";
    code += "            debugPrint(\"  Delay completed: \" + COLOR_VALUE + QString::number(m_delay) + \"ms\" + ANSI_RESET);\n";
    code += "        }\n";
    code += "        debugPrint(SECTION_SEPARATOR);\n";
    code += "        \n";
    code += "        m_conditionMet = false;\n";
    code += "    }\n\n";
    
    code += "private slots:\n";
    code += "    void triggerTransition() {\n";
    code += "        if (m_condition()) {\n";
    code += "            QEvent* customEvent = new QEvent(static_cast<QEvent::Type>(QEvent::User + 1));\n";
    code += "            machine()->postEvent(customEvent);\n";
    code += "        } else {\n";
    code += "            m_conditionMet = false;\n";
    code += "            debugPrint(\"Condition no longer valid after delay for transition \" + \n";
    code += "                      m_fromState + \" → \" + m_toState + \n";
    code += "                      \", not triggering\");\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "private:\n";
    code += "    void cancelTimerIfActive() {\n";
    code += "        if (m_timer && m_timer->isActive()) {\n";
    code += "            m_timer->stop();\n";
    code += "        }\n";
    code += "    }\n\n";
    
    code += "    void logTransitionStart() {\n";
    code += "        debugPrint(\"Condition met for transition \" + \n";
    code += "                  COSMIC_DUST + m_fromState + ANSI_RESET + \" \" + SYM_ARROW + \" \" + \n";
    code += "                  QUANTUM_GREEN + m_toState + ANSI_RESET + \n";
    code += "                  \", starting \" + STARDUST + QString::number(m_delay) + \"ms\" + ANSI_RESET + \" delay timer\");\n";
    code += "    }\n\n";
    
    code += "    std::function<bool()> m_condition;  ///< The condition to evaluate\n";
    code += "    int m_delay;                        ///< Delay in milliseconds (0 = no delay)\n";
    code += "    QString m_fromState;                ///< Source state name for logging\n";
    code += "    QString m_toState;                  ///< Target state name for logging\n";
    code += "    QString m_conditionStr;             ///< Condition string for logging\n";
    code += "    QTimer* m_timer;                    ///< Timer for delayed transitions\n";
    code += "    bool m_conditionMet;                ///< Tracks whether the condition was met\n";
    code += "};\n\n";

    code += "/**\n";
    code += " * @brief Main function that uses QStateMachine for state management\n";
    code += " */\n";
    code += "int main(int argc, char *argv[]) {\n";
    code += "    QCoreApplication app(argc, argv);\n";
    code += "    \n";
    code += "    qDebug().noquote() << \"\\n\" + DOUBLE_SEPARATOR;\n";
    code += "    qDebug().noquote() << ANSI_BOLD + COLOR_HEADER + SYM_STAR + \" \" + SYM_STAR + \" \" + SYM_STAR + \"  OBLIVION STATE MACHINE  \" + SYM_STAR + \" \" + SYM_STAR + \" \" + SYM_STAR + ANSI_RESET;\n";
    code += "    qDebug().noquote() << COLOR_TRANSITION + \"     Navigating the infinite expanse of software states\" + ANSI_RESET;\n";
    code += "    qDebug().noquote() << DOUBLE_SEPARATOR + \"\\n\";\n";
    code += "    \n";
    code += "    debugPrint(\"Starting FSM application with QStateMachine\");\n";
    code += "    debugPrint(\"State machine name: \" + ANSI_BOLD + COLOR_STATE + \"" + fsm->getName() + "\" + ANSI_RESET);\n";
    
    code += "    std::signal(SIGINT, [](int) {\n";
    code += "        qDebug().noquote() << \"\";\n";
    code += "        debugPrint(ANSI_BOLD + COLOR_ERROR + \"Interrupt received. Exiting gracefully...\" + ANSI_RESET);\n";
    code += "        QCoreApplication::quit();\n";
    code += "    });\n\n";

    QSet<QString> inputNames = fsm->getInputs();
    QSet<QString> outputNames = fsm->getOutputs();
    
    code += "    // Initialize inputs and outputs\n";
    for (const QString& input : inputNames) {
        code += "    inputs[QStringLiteral(\"" + input.trimmed() + "\")] = QString();\n";
    }
    
    for (const QString& output : outputNames) {
        code += "    outputs[QStringLiteral(\"" + output.trimmed() + "\")] = QString();\n";
    }
    code += "\n";

    code += "    QSet<QString> validInputNames;\n";
    for (const QString& input : inputNames) {
        code += "    validInputNames.insert(QStringLiteral(\"" + input.trimmed() + "\"));\n";
    }
    code += "\n";
    
    code += "    const QStringList helpLines = {\n";
    code += "        \"• \" + ANSI_BOLD + QString(\"input_name=value\").leftJustified(26) + ANSI_RESET + \"- Set an input value\",\n";
    code += "        \"• \" + ANSI_BOLD + QString(\"input_name\").leftJustified(26) + ANSI_RESET + \"- Set an input with default value 'true'\",\n";
    code += "        \"• \" + ANSI_BOLD + QString(\"status\").leftJustified(26) + ANSI_RESET + \"- Show the current system state\",\n";
    code += "        \"• \" + ANSI_BOLD + QString(\"help\").leftJustified(26) + ANSI_RESET + \"- Show this help message\",\n";
    code += "        \"• \" + ANSI_BOLD + QString(\"quit/exit\").leftJustified(26) + ANSI_RESET + \"- Exit the application\"\n";
    code += "    };\n\n";

    code += "    fsm.setObjectName(\"" + fsm->getName() + "\");\n\n";
    
    code += "    debugPrint(\"Creating states...\");\n";

    for (auto it = allStates.begin(); it != allStates.end(); ++it) {
        State* state = it.value();
        QString stateName = state->getName();
        QString stateLower = stateName.toLower();
        
        code += "    QState* " + stateLower + "State = new QState(&fsm);\n";
        code += "    " + stateLower + "State->setObjectName(\"" + stateName + "\");\n";
        code += "    debugPrint(\"  Created state: \" + COLOR_STATE + \"" + stateName + "\" + ANSI_RESET);\n";
    
        QString onEntry = state->getCode();
        if (!onEntry.isEmpty()) {
            onEntry = onEntry.replace("atoi(", "atoi_safe(");
            
            code += "    QObject::connect(" + stateLower + "State, &QState::entered, []() {\n";
            code += "        debugPrint(DOUBLE_SEPARATOR);\n";
            code += "        debugPrint(STATE_HEADER + ANSI_BOLD + COLOR_STATE + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "        debugPrint(\"Executing onEntry action for state: \" + ANSI_BOLD + \"" + stateName + "\" + ANSI_RESET);\n";
            code += "        " + onEntry + "\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "    });\n";
        } else {
            code += "    QObject::connect(" + stateLower + "State, &QState::entered, []() {\n";
            code += "        debugPrint(DOUBLE_SEPARATOR);\n";
            code += "        debugPrint(STATE_HEADER + ANSI_BOLD + COLOR_STATE + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
            code += "        debugPrint(SECTION_SEPARATOR);\n";
            code += "    });\n";
        }
        code += "\n";
    }
    
    code += "    fsm.setInitialState(" + initialStateName.toLower() + "State);\n";
    code += "    debugPrint(\"Initial state set to \" + ANSI_BOLD + COLOR_TARGET + \"" + initialStateName + "\" + ANSI_RESET);\n\n";
    
    code += "    debugPrint(\"Setting up transitions...\");\n";
    
    for (auto stateIt = allStates.begin(); stateIt != allStates.end(); ++stateIt) {
        State* sourceState = stateIt.value();
        QString sourceName = sourceState->getName();
        
        QList<Transition*> transitions = fsm->getTransitionsFrom(sourceState);
        
        for (Transition* transition : transitions) {
            State* targetState = transition->getTo();
            if (!targetState) continue;
            
            QString targetName = targetState->getName();
            
            code += generateTransitionCode(transition, sourceState, targetState);
        }
    }

    code += "    showHelp(validInputNames, helpLines);\n";
    code += "    qDebug().noquote() << \"\";\n\n";

    code += "    FILE* terminalInput = fdopen(dup(STDIN_FILENO), \"r\");\n";
    code += "    if (!terminalInput) {\n";
    code += "        debugPrint(\"Error: Could not open terminal input\", 3);\n";
    code += "        return 1;\n";
    code += "    }\n\n";
    
    code += "    int terminalFd = fileno(terminalInput);\n";
    code += "    QSocketNotifier* inputNotifier = new QSocketNotifier(terminalFd, QSocketNotifier::Read);\n\n";
    
    code += "    QObject::connect(inputNotifier, &QSocketNotifier::activated, [&]() {\n";
    code += "        char buffer[256];\n";
    code += "        if (fgets(buffer, sizeof(buffer), terminalInput)) {\n";
    code += "            QString inputLine = QString::fromLocal8Bit(buffer).trimmed();\n";
    code += "            \n";
    code += "            if (inputLine.isEmpty()) return;\n";
    code += "            \n";
    code += "            if (inputLine == \"quit\" || inputLine == \"exit\") {\n";
    code += "                debugPrint(\"Exit command received. Terminating application.\");\n";
    code += "                QCoreApplication::quit();\n";
    code += "                return;\n";
    code += "            }\n";
    code += "            \n";
    code += "            if (inputLine == \"help\") {\n";
    code += "                showHelp(validInputNames, helpLines);\n";
    code += "                return;\n";
    code += "            }\n";
    code += "            \n";
    code += "            if (inputLine == \"status\") {\n";
    code += "                QString currentState = fsm.configuration().isEmpty() ? \"UNKNOWN\" : (*fsm.configuration().begin())->objectName();\n";
    code += "                debugPrint(\"Current state: \" + ANSI_BOLD + COLOR_STATE + currentState + ANSI_RESET);\n";
    code += "                return;\n";
    code += "            }\n";
    code += "            \n";
    code += "            QRegularExpression inputRegex(\"^(\\\\w+)(?:=(.*))?$\");\n";
    code += "            QRegularExpressionMatch match = inputRegex.match(inputLine);\n";
    code += "            \n";
    code += "            if (match.hasMatch()) {\n";
    code += "                QString name = match.captured(1);\n";
    code += "                QString value = match.captured(2);\n";
    code += "                \n";
    code += "                if (!validInputNames.contains(name)) {\n";
    code += "                    debugPrint(\"Invalid input name: \" + ANSI_BOLD + WARP_RED + name + ANSI_RESET, 3);\n";
    code += "                    return;\n";
    code += "                }\n";
    code += "                \n";
    code += "                if (!value.isEmpty()) {\n";
    code += "                    // SET mode: store the new value and trigger event\n";
    code += "                    debugPrint(\"[DEBUG] SET MODE for '\" + name + \"' with value '\" + value + \"'\");\n";
    code += "                    inputs[name] = value;\n";
    code += "                    logInputEvent(name, value);\n";
    code += "                    fsm.postEvent(new InputEvent(name, value, false));\n";
    code += "                } else {\n";
    code += "                    // CALL mode: treat as pure event without changing stored value\n";
    code += "                    QString lastValue = inputs.contains(name) ? inputs[name] : QString();\n";
    code += "                    logInputEvent(name, lastValue);\n";
    code += "                    // Mark this input as having been called for event-based transitions\n";
    code += "                    setInputCalled(name);\n";
    code += "                    fsm.postEvent(new InputEvent(name, lastValue, true));\n";
    code += "                }\n";
    code += "            } else {\n";
    code += "                debugPrint(\"Unrecognized command: \" + ANSI_BOLD + WARP_RED + inputLine + ANSI_RESET, 3);\n";
    code += "            }\n";
    code += "        }\n";
    code += "    });\n\n";

    code += "    debugPrint(ANSI_BOLD + COLOR_HEADER + \"INITIALIZING STATE MACHINE\" + ANSI_RESET);\n";
    code += "    fsm.start();\n";
    code += "    debugPrint(COLOR_SUCCESS + SYM_SUCCESS + \" Transition engine activated successfully\" + ANSI_RESET);\n";
    code += "    qDebug().noquote() << \"\";\n\n";
    
    code += "    QObject::connect(&app, &QCoreApplication::aboutToQuit, [terminalInput]() {\n";
    code += "        if (terminalInput) {\n";
    code += "            fclose(terminalInput);\n";
    code += "        }\n";
    code += "    });\n\n";

    code += "    int result = app.exec();\n";
    code += "    debugPrint(\"Application terminated with code \" + QString::number(result));\n";
    code += "    return result;\n";
    code += "}\n";
    
    return code;
}
