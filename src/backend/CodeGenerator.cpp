/**
 * @file CodeGenerator.cpp
 * @brief Implementation of the CodeGenerator class for generating C++ code from
 * FSM memory instances.
 * @author xcsirim00
 * @date 8. May 2025
 */

#include "CodeGenerator.hpp"

#include <QDebug>
#include <QDomDocument>
#include <QDomElement>
#include <QRegularExpression>
#include <csignal>

#include "fsm.hpp"
#include "state.hpp"
#include "transition.hpp"
#include "variable.hpp"

/**
 * @brief Constructor for CodeGenerator.
 *
 * @param parent Optional parent QObject.
 */
CodeGenerator::CodeGenerator(QObject* parent) : QObject(parent) {}

/**
 * @brief Generate the full C++ code for a given FSM.
 *
 * @param fsm Pointer to the FSM object to generate code from.
 * @return The generated C++ code as a QString.
 */
QString CodeGenerator::generateCode(FSM* fsm) {
    QString code;

    code += "/**\n";
    code += " * Generated finite state machine: " + fsm->getName() + "\n";

    QString description = fsm->getComment();
    if (!description.isEmpty()) {
        code += " * Description: " + description + "\n";
    }

    code += " * \n";
    code +=
        " * This file was automatically generated by the Oblivion FSM code "
        "generator\n";
    code += " */\n\n";

    code += generateHeaders();
    code += generateVariableDeclarations(fsm);
    code += generateRuntimeMonitoring();
    code += generateHelperFunctions(fsm);
    code += generateMainFunction(fsm);

    return code;
}

/**
 * @brief Generate standard C++ header includes for the generated file.
 *
 * @return C++ code section with all required #include directives as a QString.
 */
QString CodeGenerator::generateHeaders() {
    return R"cpp(
#include <QtCore/QDebug>
#include <QtCore/QString>
#include <QtCore/QMap>
#include <QtCore/QDateTime>
#include <QtCore/QCoreApplication>
#include <QtCore/QTimer>
#include <QtCore/QSocketNotifier>
#include <QtCore/QStateMachine>
#include <QtCore/QState>
#include <QtCore/QEvent>
#include <QtCore/QAbstractTransition>
#include <QtCore/QRegularExpression>
#include <stdio.h>
#include <unistd.h>
#include <csignal>
#include <functional>
#include <QTcpServer>
#include <QTcpSocket>
#include <QDomDocument>
#include <QDomElement>
#include <QFile>
#include <QDir>
    )cpp";
}

/**
 * @brief Generate helper and utility functions for the generated FSM code.
 *
 * Includes helpers for input/output, value access, conversion, event flagging,
 * timer management, and status reporting.
 *
 * @param fsm Pointer to the FSM object for which helpers are generated.
 * @return C++ code section with helper functions as a QString.
 */
QString CodeGenerator::generateHelperFunctions(FSM* fsm) {
    QString code;

    code +=
        R"cpp(
        /******************************************************************************
         * Utility functions for input/output and value handling
         ******************************************************************************/

        /**
         * @brief Builds a QByteArray needed for the TCP communication.
         * @param eventString The event as a QString (XML or plain text).
         * @return QByteArray ready to send via TCP.
         */
        QByteArray buildEvent(const QString& eventString) { return (eventString + "\n").toUtf8(); }

        /**
         * @brief Gets the value of an input.
         * @param input Input name.
         * @return Current value of the input as a string, or empty if not
         * found.
         */
        QString valueof(const QString& input) {
            if (inputs.contains(input)) {
                return inputs[input];
            }
            return QString();
        }

        /**
         * @brief Converts a QString to an integer.
         * @param str String to convert.
         * @return Integer value, or 0 if conversion fails.
         */
        int Qtoi(const QString& str) {
            bool ok = false;
            int value = str.toInt(&ok);
            return ok ? value : 0;
        }

        /**
         * @brief Checks if an input is defined and has a non-empty value.
         * @param input Input name to check.
         * @return True if the input exists and has a value.
         */
        bool defined(const QString& input) { return inputs.contains(input) && !inputs[input].isEmpty(); }

        /**
         * @brief Sends an output value.
         * @param port Output destination.
         * @param value Value to send (any type supported by QVariant).
         */
        void output(const QString& port, const QVariant& value) {
            QString valueStr = value.toString();
            debug(QString("output('%1', %2)").arg(port).arg(valueStr));
            outputs[port] = valueStr;
            logOutputEvent(port, outputs[port]);

            extern QSet<QTcpSocket*> clientSockets;
            for (QTcpSocket* clientSocket : clientSockets) {
                if (clientSocket->state() == QAbstractSocket::ConnectedState) {
                    QDomDocument doc;
                    QDomElement element = doc.createElement("event");
                    element.setAttribute("type", "output");

                    QDomElement name = doc.createElement("name");
                    name.appendChild(doc.createTextNode(port));
                    QDomElement valueElem = doc.createElement("value");
                    valueElem.appendChild(doc.createTextNode(valueStr));
                    element.appendChild(name);
                    element.appendChild(valueElem);

                    doc.appendChild(element);
                    clientSocket->write(buildEvent(doc.toString(-1)));
                    clientSocket->flush();
                }
            }
        }

        /**
         * @brief Returns time elapsed since state entry in milliseconds.
         * @return Milliseconds elapsed since entering the current state.
         */
        int elapsed() {
            if (fsm.configuration().isEmpty()) {
                return 0;
            }
            QState* currentState = static_cast<QState*>(*fsm.configuration().begin());
            QVariant entryTimeVar = currentState->property("entryTime");
            if (!entryTimeVar.isValid() || !entryTimeVar.canConvert<qint64>()) {
                debug(
                    "elapsed(): entryTime property is invalid or not a "
                    "qint64");
                return 0;
            }
            qint64 entryTime = entryTimeVar.toLongLong();
            qint64 now = QDateTime::currentDateTime().toMSecsSinceEpoch();
            int diff = static_cast<int>(now - entryTime);
            debug(QString("elapsed(): entryTime=%1, now=%2, diff=%3").arg(entryTime).arg(now).arg(diff));
            return diff;
        }

        // Shared event flags for tracking input calls
        QMap<QString, bool>& getEventFlags() {
            static QMap<QString, bool> flags;
            return flags;
        }

        /**
         * @brief Checks if an input was called as an event (regardless of
         * value).
         * @param input Input name to check.
         * @return True if the input was triggered as an event.
         */
        bool called(const QString& input) {
            QMap<QString, bool>& eventFlags = getEventFlags();
            bool result = eventFlags.value(input, false);
            debug(QString("called('%1') returning %2").arg(input).arg(result ? "true" : "false"));
            eventFlags[input] = false;
            return result;
        }

        /**
         * @brief Sets the trigger flag for an input.
         * @param input Input name to mark as called.
         */
        void setInputCalled(const QString& input) {
            QMap<QString, bool>& eventFlags = getEventFlags();
            eventFlags[input] = true;
        }

        /**
         * @brief Sends a timer event to the client.
         * @param type 'timerStart' or 'timerExpired'.
         * @param from Source state name.
         * @param to Target state name.
         * @param ms Optional ms value for timerStart.
         */
        void sendTimerEvent(const QString& type, const QString& from, const QString& to, int ms = -1) {
            extern QSet<QTcpSocket*> clientSockets;
            for (QTcpSocket* clientSocket : clientSockets) {
                if (clientSocket->state() == QAbstractSocket::ConnectedState) {
                    if (type == "timerStart") {
                        clientSocket->write(buildEvent(QString("<event "
                                                               "type=\"timerStart\"><from>%1</from><to>%2</"
                                                               "to><ms>%3</ms></event>")
                                                           .arg(from)
                                                           .arg(to)
                                                           .arg(ms)));
                    } else if (type == "timerExpired") {
                        clientSocket->write(buildEvent(QString("<event "
                                                               "type=\"timerExpired\"><from>%1</"
                                                               "from><to>%2</to></event>")
                                                           .arg(from)
                                                           .arg(to)));
                    }
                    clientSocket->flush();
                }
            }
            QPair<QString, QString> timerKey = qMakePair(from, to);
            timers[timerKey] = qMakePair(QDateTime::currentMSecsSinceEpoch(), ms);
        }

        /**
         * @brief Broadcasts a shutdown event to all connected clients.
         * @param message Optional shutdown message.
         */
        void broadcastShutdownEvent(const QString& message =
                                        "Server is shutting down. All client connections will be "
                                        "closed. Please "
                                        "save your work and reconnect later.") {
            for (QTcpSocket* clientSocket : clientSockets) {
                if (clientSocket->state() == QAbstractSocket::ConnectedState) {
                    QString shutdownMsg = QString(
                                              "<event "
                                              "type=\"shutdown\"><message>%1</message></event>")
                                              .arg(message);
                    clientSocket->write(buildEvent(shutdownMsg));
                    clientSocket->flush();
                }
            }
        }

        void cleanupSocket(QTcpSocket* socket) {
            if (!socket) {
                return;
            }
            debug(QString("cleanupSocket: removing and deleting socket %1").arg(reinterpret_cast<quintptr>(socket)));
            if (clientSockets.contains(socket)) {
                clientSockets.remove(socket);
            }
            if (awaitingPong.contains(socket)) {
                awaitingPong.remove(socket);
            }
            if (pingTimers.contains(socket)) {
                QTimer* t = pingTimers.take(socket);
                if (t) {
                    t->stop();
                    t->deleteLater();
                }
            }
            socket->deleteLater();
        }

        void closeAndCleanupAllSockets() {
            auto socketsCopy = clientSockets;
            for (QTcpSocket* socket : socketsCopy) {
                cleanupSocket(socket);
            }
            clientSockets.clear();
            QCoreApplication::processEvents(QEventLoop::AllEvents, 100);
        }
        )cpp";

    code += R"cpp(
        QString generateStatusXml(const QString& state) {
            QDomDocument doc;
            QDomElement eventElem = doc.createElement("event");
            eventElem.setAttribute("type", "status");
            QDomElement root = doc.createElement("status");
            eventElem.appendChild(root);
            doc.appendChild(eventElem);

            QDomElement stateElem = doc.createElement("state");
            stateElem.appendChild(doc.createTextNode(state));
            root.appendChild(stateElem);

            QDomElement inputsElem = doc.createElement("inputs");
            for (auto it = inputs.constBegin(); it != inputs.constEnd(); ++it) {
                QDomElement inputElem = doc.createElement("input");
                inputElem.setAttribute("name", it.key());
                inputElem.appendChild(doc.createTextNode(it.value()));
                inputsElem.appendChild(inputElem);
            }
            root.appendChild(inputsElem);

            QDomElement outputsElem = doc.createElement("outputs");
            for (auto it = outputs.constBegin(); it != outputs.constEnd(); ++it) {
                QDomElement outputElem = doc.createElement("output");
                outputElem.setAttribute("name", it.key());
                outputElem.appendChild(doc.createTextNode(it.value()));
                outputsElem.appendChild(outputElem);
            }
            root.appendChild(outputsElem);

            QDomElement varsElem = doc.createElement("variables");
    )cpp";
    QMap<QString, Variable*> variables = fsm->getVariables();
    for (auto it = variables.constBegin(); it != variables.constEnd(); ++it) {
        Variable* var = it.value();
        QString varName = var->getName();
        QString varType = var->getType();
        code += "  { QDomElement varElem = doc.createElement(\"var\");\n";
        code += "    varElem.setAttribute(\"name\", \"" + varName + "\");\n";
        code += "    varElem.setAttribute(\"type\", \"" + varType + "\");\n";
        code += "    varElem.appendChild(doc.createTextNode(QVariant::fromValue(" + varName + ").toString()));\n";
        code += "    varsElem.appendChild(varElem);\n";
        code += "  }\n";
    }
    code += R"cpp(
        root.appendChild(varsElem);
        QDomElement timersElem = doc.createElement("timers");
        extern QMap<QPair<QString, QString>, QPair<qint64, int>> timers;
        for (auto it = timers.constBegin(); it != timers.constEnd(); ++it) {
            QString from = it.key().first;
            QString to = it.key().second;
            QDomElement timerElem = doc.createElement("timer");
            QDomElement fromElem = doc.createElement("from");
            fromElem.appendChild(doc.createTextNode(from));
            QDomElement toElem = doc.createElement("to");
            toElem.appendChild(doc.createTextNode(to));
            QDomElement msElem = doc.createElement("ms");
            msElem.appendChild(doc.createTextNode(QString::number(it.value().second)));
            timerElem.appendChild(fromElem);
            timerElem.appendChild(toElem);
            timerElem.appendChild(msElem);
            timersElem.appendChild(timerElem);
        }
        root.appendChild(timersElem);

        return doc.toString(-1);
        }

        /**
         * @brief Sends an error response to the client.
         * @param code Error code.
         * @param msg Error message.
         * @param socket Client socket to send the error to.
         */
        void sendError(int code, const QString& msg, QTcpSocket* socket) {
            if (!socket) return;
            QString error = QString(
                                "<event "
                                "type=\"error\"><code>%1</"
                                "code><message>%2</message></event>")
                                .arg(code)
                                .arg(msg.toHtmlEscaped());
            socket->write(buildEvent(error));
            socket->flush();
        }

        // Error codes for TCP XML protocol
        enum FsmErrorCode {
            ERR_UNKNOWN_INPUT = 21,
            ERR_UNKNOWN_COMMAND = 10,
            ERR_MALFORMED_XML = 11,
            ERR_INTERNAL = 99,
        };
    )cpp";

    return code;
}

/**
 * @brief Generate global variable declarations for the FSM and its variables.
 *
 * Declares standard and custom variables required for the generated FSM code.
 *
 * @param fsm Pointer to the FSM object containing variable definitions.
 * @return C++ code section with variable declarations as a QString.
 */
QString CodeGenerator::generateVariableDeclarations(FSM* fsm) {
    QString code =
        R"cpp(
        /******************************************************************************
         * Variable declarations
         ******************************************************************************/

        QStateMachine fsm;               // Global state machine instance
        QMap<QString, QString> inputs;   // Map of input names to values
        QMap<QString, QString> outputs;  // Map of output names to values
        bool debugEnabled = false;
        QSet<QTcpSocket*> clientSockets;
        QMap<QString, QVariant> variables;
        QMap<QPair<QString, QString>, QPair<qint64, int>> timers;  // [(from,to),(startime,duration)]
        QMap<QTcpSocket*, QTimer*> pingTimers;                     // Tracks pingpong keepalive timers per client
        QSet<QTcpSocket*> awaitingPong;                            // Tracks clients waiting for pong
        )cpp";

    QMap<QString, Variable*> variables = fsm->getVariables();
    if (!variables.isEmpty()) {
        code += "// Custom variables for " + fsm->getName() + "\n";
        for (auto it = variables.constBegin(); it != variables.constEnd(); ++it) {
            Variable* var = it.value();
            code += var->getType() + " " + var->getName() + " = " + var->getValue().toString() + ";\n";
        }
        code += "\n";
    }
    return code;
}

/**
 * @brief Generate logging and runtime monitoring functions for the FSM.
 *
 * Provides logging, debug, and help display utilities for state transitions,
 * events, and debugging.
 *
 * @return C++ code section with runtime monitoring functions as a QString.
 */
QString CodeGenerator::generateRuntimeMonitoring() {
    return R"cpp(
        /******************************************************************************
         * Runtime monitoring and debugging
         ******************************************************************************/

        const QString ANSI_RESET = "\033[0m";
        const QString ANSI_BOLD = "\033[1m";

        // Semantic Color Mappings
        const QString COLOR_STATE = "\033[38;5;93m";       // Purple
        const QString COLOR_TRANSITION = "\033[38;5;39m";  // Blueish
        const QString COLOR_SOURCE = "\033[38;5;102m";     // Gray
        const QString COLOR_TARGET = "\033[38;5;84m";      // Green
        const QString COLOR_COMMAND = "\033[38;5;231m";    // Whitish
        const QString COLOR_INPUT = "\033[38;5;75m";       // Cyan
        const QString COLOR_VALUE = "\033[38;5;153m";      // Light Blue
        const QString COLOR_HEADER = "\033[38;5;141m";     // Dark Purple

        // Status & Logging Colors
        const QString COLOR_INFO = "\033[38;5;39m";      // Blue
        const QString COLOR_NOTICE = "\033[38;5;102m";   // Grayish
        const QString COLOR_WARNING = "\033[38;5;220m";  // Yellow
        const QString COLOR_ERROR = "\033[38;5;196m";    // Red
        const QString COLOR_SUCCESS = "\033[38;5;84m";   // Greener

        // Timeout Specific Colors
        const QString TIMEOUT_STARTED = "\033[38;5;177m";  // Pinkish
        const QString TIMEOUT_EXPIRED = "\033[38;5;213m";  // Magenta

        const QString STATE_HEADER = ANSI_BOLD + COLOR_STATE + "════════ STATE: " + ANSI_RESET;
        const QString COMMAND_HEADER = ANSI_BOLD + COLOR_COMMAND + "⟫ COMMAND: " + ANSI_RESET;
        const QString SECTION_SEPARATOR = COLOR_NOTICE + "───────────────────────────────────────────────────" + ANSI_RESET;
        const QString DOUBLE_SEPARATOR = COLOR_TRANSITION + "═══════════════════════════════════════════════════" + ANSI_RESET;

        /**
         * @brief Prints a log message.
         * @param message Log message to display.
         */
        void log(const QString& message) {
            QString timeStr = QDateTime::currentDateTime().toString(
                "HH:mm:"
                "ss.zzz");
            qDebug().noquote() << "[" << timeStr << "]" << message;
        }

        /**
         * @brief Logs state transitions for monitoring.
         * @param stateName State name being entered.
         */
        void logStateChange(const QString& stateName) {
            log(DOUBLE_SEPARATOR);
            log(STATE_HEADER + ANSI_BOLD + COLOR_STATE + stateName + ANSI_RESET + " ENTERED");
            log(SECTION_SEPARATOR);
            log("Executing onEntry action for state: " + ANSI_BOLD + stateName + ANSI_RESET);
            log(SECTION_SEPARATOR);
        }

        /**
         * @brief Logs input values for monitoring.
         * @param input Input name.
         * @param value Input value.
         */
        void logInputEvent(const QString& input, const QString& value) {
            log("Input value: " + ANSI_BOLD + input + ANSI_RESET + " = " + COLOR_VALUE + value + ANSI_RESET);
        }

        /**
         * @brief Logs output values for monitoring.
         * @param output Output name.
         * @param value Output value.
         */
        void logOutputEvent(const QString& output, const QString& value) {
            log("Output value: " + ANSI_BOLD + output + ANSI_RESET + " = " + COLOR_VALUE + value + ANSI_RESET);
        }

        /**
         * @brief Prints a debug message if debugEnabled is true.
         * @param message Debug message to display.
         */
        void debug(const QString& message) {
            if (!debugEnabled) return;
            QString timeStr = QDateTime::currentDateTime().toString(
                "HH:mm:"
                "ss.zzz");
            QString prefix = COLOR_INFO + "• DEBUG" + ANSI_RESET + ": ";
            qDebug().noquote() << "[" << timeStr << "]" << prefix << message;
        }

        /**
         * @brief Displays all available commands and valid inputs.
         * @param fsmName Name of the FSM.
         * @param fsmDescription Description of the FSM.
         * @param validInputs Set of valid input names.
         * @param helpLines List of command descriptions to display.
         */
        void showHelp(const QString& fsmName, const QString& fsmDescription, const QSet<QString>& validInputs,
                      const QStringList& helpLines) {
            log(DOUBLE_SEPARATOR);
            log(ANSI_BOLD + COLOR_HEADER + "Machine: " + ANSI_RESET + COLOR_STATE + fsmName + ANSI_RESET);
            if (!fsmDescription.isEmpty()) {
                log(fsmDescription);
            }
            log(DOUBLE_SEPARATOR);
            log(ANSI_BOLD + COLOR_COMMAND + "AVAILABLE COMMANDS:" + ANSI_RESET);
            for (const QString& line : helpLines) {
                log(line);
            }
            log(SECTION_SEPARATOR);
            if (!validInputs.isEmpty()) {
                log(ANSI_BOLD + COLOR_INPUT + "VALID INPUTS:" + ANSI_RESET);
                QStringList sortedInputs = validInputs.values();
                sortedInputs.sort();
                for (const QString& input : sortedInputs) {
                    log("  " + COLOR_INPUT + input + ANSI_RESET);
                }
            }
            log(SECTION_SEPARATOR);
        }
    )cpp";
}

/**
 * @brief Generate C++ code for a single FSM transition.
 *
 * @param transition Pointer to the transition object.
 * @param sourceState Pointer to the source state.
 * @param targetState Pointer to the target state.
 * @return C++ code for the transition as a QString.
 */
QString CodeGenerator::generateTransitionCode(Transition* transition, const State* sourceState,
                                              const State* targetState) {
    QString code;
    QString sourceName = const_cast<State*>(sourceState)->getName();
    QString targetName = const_cast<State*>(targetState)->getName();
    QString sourceLower = sourceName.toLower();
    QString targetLower = targetName.toLower();

    QString condition = transition->getCondition();
    QString event = transition->getEvent();

    int delay = transition->isDelayedTransition() ? transition->getDelay() : 0;
    bool hasCondition = !condition.isEmpty();
    bool hasEvent = !event.isEmpty();
    bool hasDelay = delay > 0 || (!transition->getDelayVariableName().isEmpty() && transition->isDelayedTransition());

    static int transitionCounter = 0;
    QString transName = sourceLower + "To" + targetName + "Transition" + QString::number(++transitionCounter);

    code += " // Create transition: " + sourceName + " → " + targetName;
    if (hasEvent || hasCondition || hasDelay) {
        code += " (";
        if (hasEvent) {
            code += "event: " + event;
        }
        if (hasCondition) {
            if (hasEvent) code += ", ";
            code += "[ " + condition + " ]";
        }
        if (hasDelay) {
            if (hasEvent || hasCondition) code += " ";
            if (!transition->getDelayVariableName().isEmpty())
                code += "@ " + transition->getDelayVariableName();
            else
                code += "@ " + QString::number(delay) + "ms";
        }
        code += ")";
    }
    code += "\n";

    QString delayProvider;
    if (transition->isDelayedTransition() && !transition->getDelayVariableName().isEmpty()) {
        const QString varName = transition->getDelayVariableName();
        delayProvider = "[]() -> int { return " + varName + "; }";
    } else if (hasDelay) {
        delayProvider = "[]() -> int { return " + QString::number(delay) + "; }";
    } else {
        delayProvider = "[]() -> int { return 0; }";
    }

    code += "    GeneratedTransition* " + transName + " = new GeneratedTransition(";
    if (hasEvent && hasCondition) {
        code += "[]() -> bool {\n";
        code += "        return called(\"" + event + "\") && (" + condition + ");\n";
        code += "    }";
    } else if (hasEvent) {
        code += "[]() -> bool {\n";
        code += "        return called(\"" + event + "\");\n";
        code += "    }";
    } else if (hasCondition) {
        code += "[]() -> bool {\n";
        code += "        return " + condition + ";\n";
        code += "    }";
    } else {
        code += "[]() { return true; }";
    }
    code += ", " + delayProvider;
    code += ", \"" + sourceName + "\", \"" + targetName + "\"";
    code += ");\n";
    code += "    " + sourceLower + "State->addTransition(" + transName + ");\n";
    code += "    " + transName + "->setTargetState(" + targetLower + "State);\n\n";
    return code;
}

/**
 * @brief Generate the main function and core classes for the FSM application.
 *
 * Generates the main() function, state setup, transitions, and event loop for
 * the generated FSM code.
 *
 * @param fsm Pointer to the FSM object containing states and transitions.
 * @return C++ code section with the main function and related classes as a
 * QString.
 */
QString CodeGenerator::generateMainFunction(FSM* fsm) {
    QString code;

    code += R"cpp(
        /************************************************************************
         * Classes and Main function
         ***********************************************************************/
    )cpp";

    code += generateInputEventClass();
    code += generateGeneratedTransitionClass();

    code +=
        R"cpp(
        void clearOutgoingTimers(const QString& stateName) {
            debug(QString("clearOutgoingTimers('%1')").arg(stateName));
            // Iterate all transitions and reset timers for outgoing
            // transitions from the given state.
            for (QAbstractTransition* t : fsm.findChildren<QAbstractTransition*>()) {
                auto ut = dynamic_cast<GeneratedTransition*>(t);
                if (!ut) continue;
                const QString& from = ut->fromStateName();
                const QString& to = ut->toStateName();
                if (from == stateName && from != to) {
                    ut->resetTimerArmed();
                    ut->stopTimer();
                    debug(QString("Stopped timer and reset for transition %1 → %2").arg(from, to));
                }
            }
        }
        )cpp";

    State* initial = fsm->getInitialState();
    QMap<QString, State*> allStates = fsm->getStates();

    QString initialStateName = initial ? initial->getName() : "UNKNOWN";

    code +=
        QString(
            R"cpp(
                /**
                 * @brief Main function that uses QStateMachine for state management.
                 */
                int main(int argc, char* argv[]) {
                    QCoreApplication app(argc, argv);
                    QTcpServer server;
                    const char* FSM_XML = R"xml(%1)xml";

                    // --host and --port arguments
                    QString hostStr = "127.0.0.1";
                    quint16 port = 54323;
                    for (int i = 1; i < argc; ++i) {
                        QString arg = argv[i];
                        if (arg == "--host" && i + 1 < argc) {
                            hostStr = argv[++i];
                        } else if (arg == "--port" && i + 1 < argc) {
                            bool ok = false;
                            int p = QString(argv[++i]).toInt(&ok);
                            if (ok && p > 1024 && p < 65536) {
                                port = static_cast<quint16>(p);
                            }
                        }
                    }
                    QHostAddress hostAddr;
                    if (!hostAddr.setAddress(hostStr)) {
                        log("Invalid host address specified, defaulting to 127.0.0.1");
                        hostAddr = QHostAddress::LocalHost;
                    }

                    qDebug().noquote() << "\n" + DOUBLE_SEPARATOR;
                    qDebug().noquote() << ANSI_BOLD + COLOR_HEADER + "✧ ✧ ✧  OBLIVION STATE MACHINE  ✧ ✧ ✧" + ANSI_RESET;
                    qDebug().noquote() << COLOR_TRANSITION + "     we looove finite state machines (｡◕‿‿◕｡)" + ANSI_RESET;
                    qDebug().noquote() << DOUBLE_SEPARATOR + "\n";

                    debug("Starting FSM application with QStateMachine");
                    debug("State machine name: " + ANSI_BOLD + COLOR_STATE + "%2" + ANSI_RESET);

                    std::signal(SIGINT, [](int) {
                        log(DOUBLE_SEPARATOR);
                        log(ANSI_BOLD + COLOR_WARNING + "SIGINT (Ctrl+C) recieved. Exiting application." + ANSI_RESET);
                        log(DOUBLE_SEPARATOR);
                        broadcastShutdownEvent(
                            "Server is shutting down due to SIGINT (Ctrl+C). All clients will be disconnected.");
                        closeAndCleanupAllSockets();
                        QCoreApplication::quit();
                    });
            )cpp")
            .arg(fsm->getXml(), fsm->getName());

    QSet<QString> inputNames = fsm->getInputs();
    QSet<QString> outputNames = fsm->getOutputs();

    code += " // Initialize inputs and outputs\n";
    for (const QString& input : inputNames) {
        code += " inputs[QStringLiteral(\"" + input.trimmed() + "\")] = QString();\n";
        code += " getEventFlags()[QStringLiteral(\"" + input.trimmed() + "\")] = false;\n";
    }

    for (const QString& output : outputNames) {
        code += " outputs[QStringLiteral(\"" + output.trimmed() + "\")] = QString();\n";
    }
    code += "\n";

    code += " QSet<QString> validInputNames;\n";
    for (const QString& input : inputNames) {
        code += " validInputNames.insert(QStringLiteral(\"" + input.trimmed() + "\"));\n";
    }
    code += "\n";

    code += " fsm.setObjectName(\"" + fsm->getName() + "\");\n\n";
    code += " fsm.setProperty(\"description\", \"" + fsm->getComment() + "\");\n\n";

    code += " debug(\"Creating states...\");\n";

    code += " static QString globalPrevStateName;\n";
    for (auto it = allStates.begin(); it != allStates.end(); ++it) {
        State* state = it.value();
        QString stateName = state->getName();
        QString stateLower = stateName.toLower();
        // clang-format off
        code += QString(R"cpp(
          QState* %1State = new QState(&fsm);
          %1State->setObjectName("%2");
                    // QState::entered lambda: handles state entry logic, including logging, updating state, and running
                    // onEntry actions.
          QObject::connect(%1State, &QState::entered, [=]() {
              QString prevStateName = globalPrevStateName;
              QString currentStateName = "%2";
              if (prevStateName != currentStateName) {
                  qint64 now = QDateTime::currentDateTime().toMSecsSinceEpoch();
                  %1State->setProperty("entryTime", QVariant::fromValue(now));
                  clearOutgoingTimers("%2");
              }
              globalPrevStateName = currentStateName;
              log(DOUBLE_SEPARATOR);
              log(STATE_HEADER + ANSI_BOLD + COLOR_STATE + "%2" + ANSI_RESET + " ENTERED");
              log(SECTION_SEPARATOR);
              for (QTcpSocket* clientSocket : clientSockets) {
                  if (clientSocket->state() == QAbstractSocket::ConnectedState) {
                      QString stateMsg = QString("<event type=\"stateChange\"><name>%1</name></event>").arg(currentStateName);
                      clientSocket->write(buildEvent(stateMsg));
                      clientSocket->flush();
                  }
              }
                )cpp").arg(stateLower, stateName);

        QString onEntry = state->getCode();
        if (!onEntry.isEmpty()) {
            code += " log(\"Executing onEntry action for state: \" + ANSI_BOLD + \"" + stateName + "\" + ANSI_RESET);\n";
            code += onEntry + "\n";
        }
        code += "   log(SECTION_SEPARATOR);\n";
        code += "   log(\" \");\n";
        code += " });\n\n";
    }
    code += " fsm.setInitialState(" + initialStateName.toLower() + "State);\n";
    code += " debug(\"Initial state set to \" + ANSI_BOLD + COLOR_TARGET + \"" + initialStateName + "\" + ANSI_RESET);\n\n";
    code += " debug(\"Setting up transitions...\");\n";
    // clang-format on  

    for (auto stateIt = allStates.begin(); stateIt != allStates.end(); ++stateIt) {
        State* sourceState = stateIt.value();
        QString sourceName = sourceState->getName();
        QList<Transition*> transitions = fsm->getTransitionsFrom(sourceState);
        for (Transition* transition : transitions) {
            State* targetState = transition->getTo();
            if (!targetState) {
                continue;
            }
            QString targetName = targetState->getName();
            code += generateTransitionCode(transition, sourceState, targetState);
        }
    }

    code += R"cpp(
        const QStringList helpLines = {
            "• " + ANSI_BOLD + QString("input_name=value").leftJustified(26) + ANSI_RESET + "- Set an input value",
            "• " + ANSI_BOLD + QString("input_name").leftJustified(26) + ANSI_RESET + "- Call an input",
            "• " + ANSI_BOLD + QString("/status").leftJustified(26) + ANSI_RESET + "- Show the current system state",
            "• " + ANSI_BOLD + QString("/help").leftJustified(26) + ANSI_RESET + "- Show this help message",
            "• " + ANSI_BOLD + QString("/exit").leftJustified(26) + ANSI_RESET + "- Exit the application",
            "• " + ANSI_BOLD + QString("/debugon /debugoff").leftJustified(26) + ANSI_RESET + "- Turn debug statements on/off"};
    )cpp";

    code += "showHelp(fsm.objectName(), fsm.property(\"description\").toString(), validInputNames, helpLines);\n ";

    code += generateTerminalInputHandler(fsm);

    code += generateTcpXmlProtocolServer(fsm);

    code += R"cpp(
        debug(ANSI_BOLD + COLOR_HEADER + "INITIALIZING STATE MACHINE" + ANSI_RESET);
        fsm.start();
        debug(COLOR_SUCCESS + "✓ Transition engine activated successfully\n\n" + ANSI_RESET);
        int result = app.exec();
        debug("Application terminated with code " + QString::number(result));
        return result;
        }
    )cpp";
    return code;
}

/**
 * @brief Generate the TCP XML protocol server logic for the FSM.
 *
 * @param fsm Pointer to the FSM object.
 * @return C++ code section with TCP server logic as a QString.
 */
QString CodeGenerator::generateTcpXmlProtocolServer(FSM* fsm) {
    QString code =
        R"cpp(
        server.listen(hostAddr, port);
        log(QString("Listening for TCP connections on %1:%2").arg(hostAddr.toString()).arg(port));
        // QTcpServer::newConnection lambda
        QObject::connect(&server, &QTcpServer::newConnection, [&]() {
            while (server.hasPendingConnections()) {
                QTcpSocket* socket = server.nextPendingConnection();
                clientSockets.insert(socket);
                log("Client connected from " + socket->peerAddress().toString());
                // QTcpSocket::readyRead lambda: reads data from the socket.
                QObject::connect(socket, &QTcpSocket::readyRead, [socket, FSM_XML](void) {
                    while (socket->canReadLine()) {
                        QString line = QString::fromUtf8(socket->readLine()).trimmed();
                        debug("TCP: Received line: " + line);
                        if (line.isEmpty()) {
                            continue;
                        }
                        if (!line.startsWith("<")) {
                            debug("TCP: Non-XML command received: " + line);
                            sendError(ERR_MALFORMED_XML, "Malformed XML", socket);
                            continue;
                        }
                        QDomDocument doc;
                        if (!doc.setContent(line)) {
                            debug("TCP: Malformed XML received: " + line);
                            sendError(ERR_MALFORMED_XML, "Malformed XML", socket);
                            continue;
                        }
                        QDomElement root = doc.documentElement();
                        QString type = root.attribute("type");
                        if (type == "set") {
                            QString name = root.firstChildElement("name").text();
                            QString value = root.firstChildElement("value").text();
                            if (inputs.contains(name)) {
                                inputs[name] = value;
                                setInputCalled(name);
                                fsm.postEvent(new InputEvent(name, value));
                                log("Input '" + name + "' set to '" + value + "' via TCP");
                            } else {
                                debug("TCP: Unknown input '" + name + "' in set command");
                                sendError(ERR_UNKNOWN_INPUT, "Unknown input", socket);
                            }
                            continue;
                        } else if (type == "call") {
                            QString name = root.firstChildElement("name").text();
                            if (inputs.contains(name)) {
                                setInputCalled(name);
                                fsm.postEvent(new InputEvent(name, inputs[name]));
                                log("Input '" + name + "' called via TCP");
                            } else {
                                debug("TCP: Unknown input '" + name + "' in call command");
                                sendError(ERR_UNKNOWN_INPUT, "Unknown input", socket);
                            }
                            continue;
                        } else if (type == "status") {
                            QString state = fsm.configuration().isEmpty()
                                                ? "UNKNOWN"
                                                : (*fsm.configuration().begin())->objectName();
                            QString statusXml = generateStatusXml(state);
                            QByteArray msg = buildEvent(statusXml);
                            socket->write(msg);
                            socket->flush();
                            debug("TCP: Sent status XML");
                            continue;
                        } else if (type == "help") {
                            QString helpMsg =
                                "<event type=\"log\"><message>Supported "
                                "commands: set, call, status, reqFSM, help, "
                                "disconnect, shutdown</message></event>";
                            socket->write(buildEvent(helpMsg));
                            socket->flush();
                            debug("TCP: Sent help message");
                            continue;
                        } else if (type == "reqFSM") {
                            QString fsmMsgLine = QString::fromUtf8(FSM_XML).replace('\n', ' ').replace('\r', ' ');
                            QString fsmMsg = QString(
                                                 "<event "
                                                 "type=\"fsm\"><model><![CDATA[%"
                                                 "1]]></model></event>")
                                                 .arg(fsmMsgLine);
                            socket->write(buildEvent(fsmMsg));
                            socket->flush();
                            debug("TCP: FSM model XML sent to client");
                            continue;
                        } else if (type == "disconnect") {
                            QString disconnectMsg =
                                "<event "
                                "type=\"disconnect\"><message>Disconnecting "
                                "client</message></event>";
                            socket->write(buildEvent(disconnectMsg));
                            socket->flush();
                            socket->disconnectFromHost();
                            debug(
                                "TCP: Client requested disconnect via socket "
                                "communication");
                            continue;
                        } else if (type == "shutdown") {
                            broadcastShutdownEvent(
                                "Server is shutting down due to a TCP shutdown "
                                "command. All clients will be disconnected.");
                            log("Shutdown command received via socket "
                                "communication. Shutting down server.");
                            closeAndCleanupAllSockets();
                            QCoreApplication::quit();
                            continue;
                        } else if (type == "pong") {
                            if (awaitingPong.contains(socket)) {
                                awaitingPong.remove(socket);
                                if (pingTimers.contains(socket)) {
                                    QTimer* t = pingTimers.take(socket);
                                    if (t) {
                                        t->stop();
                                        t->deleteLater();
                                    }
                                }
                                debug("Received pong from a client.");
                            }
                            continue;
                        } else {
                            debug("TCP: Unknown XML command received: " + type);
                            sendError(ERR_UNKNOWN_COMMAND, "Unknown command", socket);
                            continue;
                        }
                    }
                });

                // QTcpSocket::disconnected lambda
                QObject::connect(socket, &QTcpSocket::disconnected, [socket]() {
                    log("Client disconnected");
                    cleanupSocket(socket);
                });

                // QTcpSocket::error lambda
                // Done this way to avoid ambiguity because in Qt5.9 there are multiple overloaded error signals
                QObject::connect(socket,
                                 // Explicitly choosing the right signal overload
                                 static_cast<void (QTcpSocket::*)(QAbstractSocket::SocketError)>(&QTcpSocket::error),
                                 [socket](QAbstractSocket::SocketError socketError) {
                                     log(QString("Socket error occurred: %1").arg(socket->errorString()));
                                     cleanupSocket(socket);
                                 });
            }
        });

        QTimer* pingIntervalTimer = new QTimer(&app);
        pingIntervalTimer->setInterval(20000);  // 20s
        // QTimer::timeout (pingIntervalTimer lambda: Periodically sends ping messages to all clients for keepalive mechanism.
        QObject::connect(pingIntervalTimer, &QTimer::timeout, [&]() {
            for (QTcpSocket* clientSocket : clientSockets) {
                if (!awaitingPong.contains(clientSocket)) {
                    // Send ping
                    QString pingMsg = "<event type=\"ping\"/>";
                    clientSocket->write(buildEvent(pingMsg));
                    clientSocket->flush();
                    awaitingPong.insert(clientSocket);
                    debug("Sent ping to a client.\n");

                    // Expect pong
                    QTimer* pongTimer = new QTimer(clientSocket);
                    pongTimer->setSingleShot(true);
                    // QTimer::timeout (pongTimer): Handles keepalive timeout for individual clients.
                    QObject::connect(pongTimer, &QTimer::timeout, [clientSocket]() {
                        debug("A client timed out.");
                        QString shutdownMsg =
                            "<event type=\"shutdown\"><message>Keepalive "
                            "timeout</message></event>";
                        clientSocket->write(buildEvent(shutdownMsg));
                        clientSocket->flush();
                        cleanupSocket(clientSocket);
                    });
                    pingTimers[clientSocket] = pongTimer;
                    pongTimer->start(10000); // 10 s
                }
            }
        });
        pingIntervalTimer->start();
        )cpp";
    return code;
}

/**
 * @brief Generate the terminal input handler logic for the FSM.
 *
 * @param fsm Pointer to the FSM object.
 * @return C++ code section with terminal input handler as a QString.
 */
QString CodeGenerator::generateTerminalInputHandler(FSM* fsm) {
    QString code = R"cpp(
    FILE* terminalInput = fdopen(dup(STDIN_FILENO), "r");
    if (!terminalInput) {
        debug("Error: Could not open terminal input");
        return 1;
    }

    int terminalFd = fileno(terminalInput);
    QSocketNotifier* inputNotifier = new QSocketNotifier(terminalFd, QSocketNotifier::Read);

    // QSocketNotifier::activated lambda: terminal input processing
    QObject::connect(inputNotifier, &QSocketNotifier::activated, [&]() {
    char buffer[256];
    if (fgets(buffer, sizeof(buffer), terminalInput)) {
        QString inputLine = QString::fromLocal8Bit(buffer).trimmed();

        if (inputLine.isEmpty()) {
            return;
        }

        if (inputLine == "/exit") {
            log("Quit command received. Terminating application.");
            broadcastShutdownEvent(
                "Server is shutting down due to /exit command. All clients will be "
                "disconnected.");
            closeAndCleanupAllSockets();
            QCoreApplication::quit();
            return;
        }

        if (inputLine == "/help") {
            showHelp(fsm.objectName(), fsm.property("description").toString(), validInputNames, helpLines);
            return;
        }

        if (inputLine == "/status") {
            QString currentState =
                fsm.configuration().isEmpty() ? "UNKNOWN" : (*fsm.configuration().begin())->objectName();
            log("Current state: " + ANSI_BOLD + COLOR_STATE + currentState + ANSI_RESET);
            // Show debug state
            log(SECTION_SEPARATOR);
            log(ANSI_BOLD + COLOR_HEADER + "DEBUG STATE:" + ANSI_RESET);
            log(QString("  Debug output is ") +
                (debugEnabled ? (COLOR_SUCCESS + "ENABLED" + ANSI_RESET) : (COLOR_WARNING + "DISABLED" + ANSI_RESET)));
            // Show client connection status
            log(SECTION_SEPARATOR);
            log(ANSI_BOLD + COLOR_HEADER + "CLIENT CONNECTIONS:" + ANSI_RESET);
            for (QTcpSocket* clientSocket : clientSockets) {
                if (clientSocket->state() == QAbstractSocket::ConnectedState) {
                    log("  " + COLOR_SUCCESS + "Client connected" + ANSI_RESET + " (" +
                        clientSocket->peerAddress().toString() + ")");
                } else {
                    log("  " + COLOR_WARNING + "Client disconnected" + ANSI_RESET);
                }
            }
            // Show inputs
            log(SECTION_SEPARATOR);
            log(ANSI_BOLD + COLOR_HEADER + "INPUTS:" + ANSI_RESET);
            for (auto it = inputs.constBegin(); it != inputs.constEnd(); ++it) {
                log("  " + COLOR_COMMAND + it.key() + ANSI_RESET + " = " + COLOR_VALUE + it.value() + ANSI_RESET);
            }
            // Show outputs
            log(SECTION_SEPARATOR);
            log(ANSI_BOLD + COLOR_HEADER + "OUTPUTS:" + ANSI_RESET);
            for (auto it = outputs.constBegin(); it != outputs.constEnd(); ++it) {
                log("  " + COLOR_COMMAND + it.key() + ANSI_RESET + " = " + COLOR_VALUE + it.value() + ANSI_RESET);
            }
            // Show internal variables
            log(SECTION_SEPARATOR);
            log(ANSI_BOLD + COLOR_HEADER + "INTERNAL VARIABLES:" + ANSI_RESET);
    )cpp";

    QMap<QString, Variable*> variables = fsm->getVariables();
    for (auto it = variables.constBegin(); it != variables.constEnd(); ++it) {
        Variable* var = it.value();
        QString varName = var->getName();
        code += " log(\"  \" + COLOR_COMMAND + \"" + varName +
                "\" + ANSI_RESET + \" = \" + COLOR_VALUE + QVariant::fromValue(" 
                + varName + ").toString() + ANSI_RESET);\n";
    }

    code +=
        R"cpp(
        log(SECTION_SEPARATOR);
        return;
        }

        if (inputLine == "/debugon") {
            debugEnabled = true;
            log("Debug output enabled.");
            return;
        }
        if (inputLine == "/debugoff") {
            debugEnabled = false;
            log("Debug output disabled.");
            return;
        }

        QRegularExpression inputRegex("^(\\w+)(?:=(.*))?$");
        QRegularExpressionMatch match = inputRegex.match(inputLine);

        if (match.hasMatch()) {
            QString name = match.captured(1);
            QString value = match.captured(2);

            if (!validInputNames.contains(name)) {
                log("Invalid input name: " + ANSI_BOLD + COLOR_ERROR + name + ANSI_RESET);
                return;
            }

            if (!value.isEmpty()) {
                // SET mode: store the new value and trigger event
                debug("SET MODE for '" + name + "' with value '" + value + "'");
                inputs[name] = value;
                logInputEvent(name, value);
                setInputCalled(name);
                fsm.postEvent(new InputEvent(name, value));
            } else {
                // CALL mode: treat as pure event without changing stored value
                debug("CALL MODE for '" + name + "'");
                QString lastValue = inputs.contains(name) ? inputs[name] : QString();
                logInputEvent(name, lastValue);
                setInputCalled(name);
                fsm.postEvent(new InputEvent(name, lastValue));
            }
        } else {
            log("Unrecognized command: " + ANSI_BOLD + COLOR_ERROR + inputLine + ANSI_RESET);
        }
        }
        else {
            log(DOUBLE_SEPARATOR);
            log(ANSI_BOLD + COLOR_WARNING + "EOF (Ctrl+D) received. Exiting application." + ANSI_RESET);
            log(DOUBLE_SEPARATOR);
            if (terminalInput) {
                fclose(terminalInput);
                terminalInput = nullptr;
            }
            broadcastShutdownEvent(
                "Server is shutting down due to EOF (Ctrl+D) on terminal. "
                "All clients will be "
                "disconnected.");
            closeAndCleanupAllSockets();
            QCoreApplication::quit();
        }
    });
)cpp";
    return code;
}

/**
 * @brief Generate the InputEvent class for FSM input events.
 *
 * Defines a custom QEvent subclass for input changes in the generated FSM code.
 *
 * @return C++ code section with the InputEvent class as a QString.
 */
QString CodeGenerator::generateInputEventClass() {
    return R"cpp(
        /**
         * @brief Custom event for input changes.
         */
        class InputEvent : public QEvent {
           public:
            static const QEvent::Type InputChangedType =
                static_cast<QEvent::Type>(QEvent::User + 2);  // Custom event type for input changes
            InputEvent(const QString& name, const QString& value) : QEvent(InputChangedType), m_name(name), m_value(value) {}
            QString name() const { return m_name; }
            QString value() const { return m_value; }

           private:
            QString m_name;
            QString m_value;
        };
    )cpp";
}

/**
 * @brief Generate the GeneratedTransition class for FSM transitions.
 *
 * Defines a custom QAbstractTransition subclass for runtime transitions in the
 * generated FSM code.
 *
 * @return C++ code section with the GeneratedTransition class as a QString.
 */
QString CodeGenerator::generateGeneratedTransitionClass() {
    return R"cpp(
        /**
         * @brief Transition class handling both conditions and delays, generated
         * for runtime.
         */
        class GeneratedTransition : public QAbstractTransition {
           public:
            explicit GeneratedTransition(
                std::function<bool()> condition = []() { return true; },
                std::function<int()> delayFn = []() { return 0; }, const QString& fromState = QString(),
                const QString& toState = QString())
                : m_condition(std::move(condition)),
                  m_delayFn(std::move(delayFn)),
                  m_fromState(fromState),
                  m_toState(toState),
                  m_timer(new QTimer(this)),
                  m_conditionMet(false),
                  m_timerArmed(false),
                  m_timerExpired(false),
                  m_initialDelay(-1) {
                m_timer->setSingleShot(true);
                connect(m_timer, &QTimer::timeout, this, &GeneratedTransition::triggerTransition);
            }
            void resetTimerArmed() {
                m_timerArmed = false;
                m_initialDelay = -1;
            }
            void stopTimer() {
                if (m_timer && m_timer->isActive()) m_timer->stop();
            }
            QString fromStateName() const { return m_fromState; }
            QString toStateName() const { return m_toState; }

           protected:
            bool eventTest(QEvent* event) override {
                if (event->type() == QEvent::User + 1 && m_timerExpired) {
                    m_timerExpired = false;
                    if (m_condition()) {
                        return true;
                    } else {
                        m_conditionMet = false;
                        cancelTimerIfActive("Condition is no longer met (input or variable changed).");
                        return false;
                    }
                }
                try {
                    m_conditionMet = m_condition();
                    debug("Evaluating transition from " + m_fromState + " to " + m_toState + ": " +
                          (m_conditionMet ? "true" : "false"));
                    if (!m_conditionMet) {
                        cancelTimerIfActive("Condition is no longer met (input or variable changed).");
                        return false;
                    }
                    if (m_initialDelay == -1) {
                        m_initialDelay = m_delayFn();
                        debug("Initial delay for transition " + m_fromState + " → " + m_toState + ": " +
                              QString::number(m_initialDelay) + " ms");
                    }
                    const int effDelay = m_initialDelay;
                    if (effDelay > 0) {
                        if (!m_timerArmed && m_initialDelay == effDelay) {
                            logTransitionStart(effDelay);
                            sendTimerEvent("timerStart", m_fromState, m_toState, effDelay);
                            m_timer->start(effDelay);
                            m_timerArmed = true;
                        }
                        return false;
                    }
                    return m_conditionMet;
                } catch (const std::exception& e) {
                    log("Error evaluating transition condition: " + QString::fromStdString(e.what()));
                    return false;
                } catch (...) {
                    log("Unknown error evaluating transition condition");
                    return false;
                }
            }
            void onTransition(QEvent* event) override {
                Q_UNUSED(event);
                m_conditionMet = false;
                m_timerArmed = false;
                m_timerExpired = false;
                m_initialDelay = -1;
            }
           private slots:
            void triggerTransition() {
                if (m_condition()) {
                    m_timerExpired = true;
                    log(TIMEOUT_EXPIRED + ANSI_BOLD + "▶ Timeout expired" + ANSI_RESET + " for transition " +
                        COLOR_SOURCE + m_fromState + ANSI_RESET + COLOR_TRANSITION + " → " + COLOR_TARGET + m_toState +
                        ANSI_RESET + ANSI_RESET + " (delay: " + ANSI_BOLD + QString::number(m_initialDelay) + " ms)" +
                        ANSI_RESET);
                    sendTimerEvent("timerExpired", m_fromState, m_toState);
                    QEvent* customEvent = new QEvent(static_cast<QEvent::Type>(QEvent::User + 1));
                    machine()->postEvent(customEvent);
                } else {
                    m_conditionMet = false;
                    cancelTimerIfActive("Condition became false before timeout expired.");
                    debug("Condition no longer valid after delay for transition " + m_fromState + " → " + m_toState +
                          ", not triggering");
                }
            }

           private:
            void cancelTimerIfActive(const QString& reason = QString()) {
                if (m_timer && m_timer->isActive()) {
                    QString msg = "Cancelling timer for transition " + m_fromState + " → " + m_toState;
                    if (!reason.isEmpty()) {
                        msg += ": " + reason;
                    }
                    log(msg);
                    m_timer->stop();
                    m_timerArmed = false;
                    m_initialDelay = -1;
                }
            }
            void logTransitionStart(int effDelay) {
                log(TIMEOUT_STARTED + ANSI_BOLD + "▶ Timeout started" + ANSI_RESET + " for transition " + COLOR_SOURCE +
                    m_fromState + ANSI_RESET + COLOR_TRANSITION + " → " + COLOR_TARGET + m_toState + ANSI_RESET +
                    ANSI_RESET + " (delay: " + ANSI_BOLD + QString::number(effDelay) + " ms)" + ANSI_RESET);
                debug("Condition met for transition " + COLOR_SOURCE + m_fromState + ANSI_RESET + " → " + COLOR_TARGET +
                      m_toState + ANSI_RESET + ", starting " + COLOR_VALUE + QString::number(effDelay) + "ms" +
                      ANSI_RESET + " delay timer");
            }
            std::function<bool()> m_condition;
            std::function<int()> m_delayFn;
            QString m_fromState;
            QString m_toState;
            QTimer* m_timer;
            bool m_conditionMet;
            bool m_timerArmed = false;
            bool m_timerExpired = false;
            int m_initialDelay = -1;
        };
    )cpp";
}
