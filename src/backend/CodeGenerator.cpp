#include "CodeGenerator.hpp"

#include <QDebug>
#include <QDomDocument>
#include <QDomElement>
#include <QRegularExpression>
#include <csignal>

#include "fsm.hpp"
#include "state.hpp"
#include "transition.hpp"
#include "variable.hpp"

/**
 * @brief Constructor for the CodeGenerator class.
 * @param parent The parent QObject.
 */
CodeGenerator::CodeGenerator(QObject* parent) : QObject(parent) {
}

/**
 * @brief Generates C++ code from an FSM memory representation.
 *
 * This is the top-level entry point for code generation. It assembles all code sections
 * including headers, variable declarations, runtime monitoring, helper functions, and the main function.
 *
 * @param fsm The state machine to generate code from.
 * @return Generated C++ code as a QString.
 */
QString CodeGenerator::generateCode(FSM* fsm) {
  QString code;

  code += "/**\n";
  code += " * Generated Finite State Machine: " + fsm->getName() + "\n";

  QString description = fsm->getComment();
  if (!description.isEmpty()) {
    code += " * Description: " + description + "\n";
  }

  code += " * \n";
  code += " * This file was automatically generated by ICP FSM Code Generator\n";
  code += " */\n\n";

  code += generateHeaders();
  code += generateVariableDeclarations(fsm);
  code += generateRuntimeMonitoring();
  code += generateHelperFunctions(fsm);
  code += generateMainFunction(fsm);

  return code;
}

/**
 * @brief Generates standard C++ header includes for the generated file.
 * @return Code section as QString.
 */
QString CodeGenerator::generateHeaders() {
  QString code;

  code += "#include <QtCore/QDebug>\n";
  code += "#include <QtCore/QString>\n";
  code += "#include <QtCore/QMap>\n";
  code += "#include <QtCore/QDateTime>\n";
  code += "#include <QtCore/QCoreApplication>\n";
  code += "#include <QtCore/QTimer>\n";
  code += "#include <QtCore/QSocketNotifier>\n";
  code += "#include <QtCore/QStateMachine>\n";
  code += "#include <QtCore/QState>\n";
  code += "#include <QtCore/QEvent>\n";
  code += "#include <QtCore/QAbstractTransition>\n";
  code += "#include <QtCore/QRegularExpression>\n";
  code += "#include <stdio.h>\n";
  code += "#include <unistd.h>\n";
  code += "#include <csignal>\n";
  code += "#include <functional>\n";
  code += "#include <QTcpServer>\n";
  code += "#include <QTcpSocket>\n";
  code += "#include <QDomDocument>\n";
  code += "#include <QDomElement>\n";
  code += "#include <QFile>\n";
  code += "#include <QDir>\n";

  code += "\n";

  return code;
}

/**
 * @brief Provides basic helpers for managing input/output values and timers.
 *
 * Includes utility functions for value access, conversion, event flagging, and timer management.
 *
 * @param fsm The state machine to generate helper functions for.
 * @return Code section as QString.
 */
QString CodeGenerator::generateHelperFunctions(FSM* fsm) {
  QString code;

  code += "/******************************************************************************\n";
  code += " * Utility functions for input/output and value handling\n";
  code += " ******************************************************************************/\n";

  code += "/**\n";
  code += " * @brief Builds a QByteArray needed for the TCP communication.\n";
  code += " * @param eventString The event as a QString (XML or plain text).\n";
  code += " * @return QByteArray ready to send via TCP.\n";
  code += " */\n";
  code += "QByteArray buildEvent(const QString& eventString) {\n";
  code += "    return (eventString + \"\\n\").toUtf8();\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Gets the value of an input.\n";
  code += " * @param input Input name.\n";
  code += " * @return Current value of the input as a string, or empty if not found.\n";
  code += " */\n";
  code += "QString valueof(const QString &input) {\n";
  code += "    if (inputs.contains(input)) {\n";
  code += "        return inputs[input];\n";
  code += "    }\n";
  code += "    return QString();\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Converts a string to an integer.\n";
  code += " * @param str String to convert.\n";
  code += " * @return Integer value, or 0 if conversion fails.\n";
  code += " */\n";
  code += "int atoi(const QString &str) {\n";
  code += "    bool ok = false;\n";
  code += "    int value = str.toInt(&ok);\n";
  code += "    return ok ? value : 0;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Checks if an input is defined and has a non-empty value.\n";
  code += " * @param input Input name to check.\n";
  code += " * @return True if the input exists and has a value.\n";
  code += " */\n";
  code += "bool defined(const QString &input) {\n";
  code += "    return inputs.contains(input) && !inputs[input].isEmpty();\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Sends an output value.\n";
  code += " * @param port Output destination.\n";
  code += " * @param value Value to send (any type supported by QVariant).\n";
  code += " */\n";
  code += "void output(const QString &port, const QVariant &value) {\n";
  code += "    QString valueStr = value.toString();\n";
  code += "    debug(QString(\"output('%1', %2)\").arg(port).arg(valueStr));\n";
  code += "    outputs[port] = valueStr;\n";
  code += "    logOutputEvent(port, outputs[port]);\n\n";

  code += "    extern QSet<QTcpSocket*> clientSockets;\n";
  code += "    for (QTcpSocket* clientSocket : clientSockets) {\n";
  code += "        if (clientSocket->state() == QAbstractSocket::ConnectedState) {\n";
  code += "            QDomDocument doc;\n";
  code += "            QDomElement element = doc.createElement(\"event\");\n";
  code += "            element.setAttribute(\"type\", \"output\");\n\n";

  code += "            QDomElement name = doc.createElement(\"name\");\n";
  code += "            name.appendChild(doc.createTextNode(port));\n";
  code += "            QDomElement valueElem = doc.createElement(\"value\");\n";
  code += "            valueElem.appendChild(doc.createTextNode(valueStr));\n";
  code += "            element.appendChild(name);\n";
  code += "            element.appendChild(valueElem);\n\n";

  code += "            doc.appendChild(element);\n";
  code += "            clientSocket->write(buildEvent(doc.toString(-1)));\n";
  code += "            clientSocket->flush();\n";
  code += "        }\n";
  code += "    }\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Returns time elapsed since state entry in milliseconds.\n";
  code += " * @return Milliseconds elapsed since entering the current state.\n";
  code += " */\n";
  code += "int elapsed() {\n";
  code += "    if (fsm.configuration().isEmpty()) { return 0; }\n";
  code += "    QState* currentState = static_cast<QState*>(*fsm.configuration().begin());\n";
  code += "    QVariant entryTimeVar = currentState->property(\"entryTime\");\n";
  code += "    if (!entryTimeVar.isValid() || !entryTimeVar.canConvert<qint64>()) {\n";
  code += "        debug(\"elapsed(): entryTime property is invalid or not a qint64\");\n";
  code += "        return 0;\n";
  code += "    }\n";
  code += "    qint64 entryTime = entryTimeVar.toLongLong();\n";
  code += "    qint64 now = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
  code += "    int diff = static_cast<int>(now - entryTime);\n";
  code += "    debug(QString(\"elapsed(): entryTime=%1, now=%2, diff=%3\").arg(entryTime).arg(now).arg(diff));\n";
  code += "    return diff;\n";
  code += "}\n\n";

  code += "// Shared event flags for tracking input calls\n";
  code += "QMap<QString, bool>& getEventFlags() {\n";
  code += "    static QMap<QString, bool> flags;\n";
  code += "    return flags;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Checks if an input was called as an event (regardless of value).\n";
  code += " * @param input Input name to check.\n";
  code += " * @return True if the input was triggered as an event.\n";
  code += " */\n";
  code += "bool called(const QString &input) {\n";
  code += "    QMap<QString, bool>& eventFlags = getEventFlags();\n";
  code += "    bool result = eventFlags.value(input, false);\n";
  code += "    debug(QString(\"called('%1') returning %2\").arg(input).arg(result ? \"true\" : \"false\"));\n";
  code += "    eventFlags[input] = false;\n";
  code += "    return result;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Sets the trigger flag for an input.\n";
  code += " * @param input Input name to mark as called.\n";
  code += " */\n";
  code += "void setInputCalled(const QString &input) {\n";
  code += "    QMap<QString, bool>& eventFlags = getEventFlags();\n";
  code += "    eventFlags[input] = true;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Sends a timer event to the client.\n";
  code += " * @param type 'timerStart' or 'timerExpired'.\n";
  code += " * @param from Source state name.\n";
  code += " * @param to Target state name.\n";
  code += " * @param ms Optional ms value for timerStart.\n";
  code += " */\n";
  code += "void sendTimerEvent(const QString& type, const QString& from, const QString& to, int ms = -1) {\n";
  code += "    extern QSet<QTcpSocket*> clientSockets;\n";
  code += "    for (QTcpSocket* clientSocket : clientSockets) {\n";
  code += "        if (clientSocket->state() == QAbstractSocket::ConnectedState) {\n";
  code += "            if (type == \"timerStart\") {\n";
  code += "                clientSocket->write(buildEvent(QString(\"<event type=\\\"timerStart\\\"><from>%1</from><to>%2</to><ms>%3</ms></event>\").arg(from).arg(to).arg(ms)));\n";
  code += "            } else if (type == \"timerExpired\") {\n";
  code += "                clientSocket->write(buildEvent(QString(\"<event type=\\\"timerExpired\\\"><from>%1</from><to>%2</to></event>\").arg(from).arg(to)));\n";
  code += "            }\n";
  code += "            clientSocket->flush();\n";
  code += "        }\n";
  code += "    }\n";
  code += "    QPair<QString, QString> timerKey = qMakePair(from, to);\n";
  code += "    timers[timerKey] = qMakePair(QDateTime::currentMSecsSinceEpoch(), ms);\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Broadcasts a shutdown event to all connected clients.\n";
  code += " * @param message Optional shutdown message.\n";
  code += " */\n";
  code += "void broadcastShutdownEvent(const QString& message = \"Server is shutting down. All client connections will be closed. Please save your work and reconnect later.\") {\n";
  code += "    for (QTcpSocket* clientSocket : clientSockets) {\n";
  code += "        if (clientSocket->state() == QAbstractSocket::ConnectedState) {\n";
  code += "            QString shutdownMsg = QString(\"<event type=\\\"shutdown\\\"><message>%1</message></event>\").arg(message);\n";
  code += "            clientSocket->write(buildEvent(shutdownMsg));\n";
  code += "            clientSocket->flush();\n";
  code += "        }\n";
  code += "    }\n";
  code += "}\n\n";

  code += "void cleanupSocket(QTcpSocket* socket) {\n";
  code += "    if (!socket) {\n";
  code += "        return;\n";
  code += "    }\n";
  code += "    debug(QString(\"cleanupSocket: removing and deleting socket %1\").arg(reinterpret_cast<quintptr>(socket)));\n";
  code += "    if (clientSockets.contains(socket)) {\n";
  code += "        clientSockets.remove(socket);\n";
  code += "    }\n";
  code += "    if (awaitingPong.contains(socket)) {\n";
  code += "        awaitingPong.remove(socket);\n";
  code += "    }\n";
  code += "    if (pingTimers.contains(socket)) {\n";
  code += "        QTimer* t = pingTimers.take(socket);\n";
  code += "        if (t) { t->stop(); t->deleteLater(); }\n";
  code += "    }\n";
  code += "    socket->deleteLater();\n";
  code += "}\n\n";

  code += "void closeAndCleanupAllSockets() {\n";
  code += "    auto socketsCopy = clientSockets;\n";
  code += "    for (QTcpSocket* socket : socketsCopy) {\n";
  code += "        cleanupSocket(socket);\n";
  code += "    }\n";
  code += "    clientSockets.clear();\n";
  code += "    QCoreApplication::processEvents(QEventLoop::AllEvents, 100);\n";
  code += "}\n\n";

  code += "QString generateStatusXml(const QString& state) {\n";
  code += "  QDomDocument doc;\n";
  code += "  QDomElement eventElem = doc.createElement(\"event\");\n";
  code += "  eventElem.setAttribute(\"type\", \"status\");\n";
  code += "  QDomElement root = doc.createElement(\"status\");\n";
  code += "  eventElem.appendChild(root);\n";
  code += "  doc.appendChild(eventElem);\n";

  code += "  QDomElement stateElem = doc.createElement(\"state\");\n";
  code += "  stateElem.appendChild(doc.createTextNode(state));\n";
  code += "  root.appendChild(stateElem);\n";

  code += "  QDomElement inputsElem = doc.createElement(\"inputs\");\n";
  code += "  for (auto it = inputs.constBegin(); it != inputs.constEnd(); ++it) {\n";
  code += "    QDomElement inputElem = doc.createElement(\"input\");\n";
  code += "    inputElem.setAttribute(\"name\", it.key());\n";
  code += "    inputElem.appendChild(doc.createTextNode(it.value()));\n";
  code += "    inputsElem.appendChild(inputElem);\n";
  code += "  }\n";
  code += "  root.appendChild(inputsElem);\n";

  code += "  QDomElement outputsElem = doc.createElement(\"outputs\");\n";
  code += "  for (auto it = outputs.constBegin(); it != outputs.constEnd(); ++it) {\n";
  code += "    QDomElement outputElem = doc.createElement(\"output\");\n";
  code += "    outputElem.setAttribute(\"name\", it.key());\n";
  code += "    outputElem.appendChild(doc.createTextNode(it.value()));\n";
  code += "    outputsElem.appendChild(outputElem);\n";
  code += "  }\n";
  code += "  root.appendChild(outputsElem);\n";

  code += "  QDomElement varsElem = doc.createElement(\"variables\");\n";
  QMap<QString, Variable*> variables = fsm->getVariables();
  for (auto it = variables.constBegin(); it != variables.constEnd(); ++it) {
    Variable* var = it.value();
    QString varName = var->getName();
    QString varType = var->getType();
    code += "  { QDomElement varElem = doc.createElement(\"var\");\n";
    code += "    varElem.setAttribute(\"name\", \"" + varName + "\");\n";
    code += "    varElem.setAttribute(\"type\", \"" + varType + "\");\n";
    code += "    varElem.appendChild(doc.createTextNode(QVariant::fromValue(" + varName + ").toString()));\n";
    code += "    varsElem.appendChild(varElem);\n";
    code += "  }\n";
  }
  code += "  root.appendChild(varsElem);\n";

  code += "  QDomElement timersElem = doc.createElement(\"timers\");\n";
  code += "  extern QMap<QPair<QString, QString>, QPair<qint64, int>> timers;\n";
  code += "  for (auto it = timers.constBegin(); it != timers.constEnd(); ++it) {\n";
  code += "    QString from = it.key().first;\n";
  code += "    QString to = it.key().second;\n";
  code += "    QDomElement timerElem = doc.createElement(\"timer\");\n";
  code += "    QDomElement fromElem = doc.createElement(\"from\");\n";
  code += "    fromElem.appendChild(doc.createTextNode(from));\n";
  code += "    QDomElement toElem = doc.createElement(\"to\");\n";
  code += "    toElem.appendChild(doc.createTextNode(to));\n";
  code += "    QDomElement msElem = doc.createElement(\"ms\");\n";
  code += "    msElem.appendChild(doc.createTextNode(QString::number(it.value().second)));\n";
  code += "    timerElem.appendChild(fromElem);\n";
  code += "    timerElem.appendChild(toElem);\n";
  code += "    timerElem.appendChild(msElem);\n";
  code += "    timersElem.appendChild(timerElem);\n";
  code += "  }\n";
  code += "  root.appendChild(timersElem);\n";

  code += "  return doc.toString(-1);\n";
  code += "}\n";

  code += "/**\n";
  code += " * @brief Sends an error response to the client.\n";
  code += " * @param code Error code.\n";
  code += " * @param msg Error message.\n";
  code += " * @param socket Client socket to send the error to.\n";
  code += " */\n";
  code += "void sendError(int code, const QString& msg, QTcpSocket* socket) {\n";
  code += "    if (!socket) return;\n";
  code += "    QString error = QString(\"<event type=\\\"error\\\"><code>%1</code><message>%2</message></event>\")\n";
  code += "        .arg(code)\n";
  code += "        .arg(msg.toHtmlEscaped());\n";
  code += "    socket->write(buildEvent(error));\n";
  code += "    socket->flush();\n";
  code += "}\n\n";

  code += "// Error codes for TCP XML protocol\n";
  code += "enum FsmErrorCode {\n";
  code += "    ERR_UNKNOWN_INPUT      = 21,\n";
  code += "    ERR_UNKNOWN_COMMAND    = 10,\n";
  code += "    ERR_MALFORMED_XML      = 11,\n";
  code += "    ERR_INTERNAL           = 99,\n";
  code += "};\n\n";

  return code;
}

/**
 * @brief Generates global declarations for standard and custom FSM variables.
 * @param fsm State machine containing variable definitions.
 * @return Code section as QString.
 */
QString CodeGenerator::generateVariableDeclarations(FSM* fsm) {
  QString code;

  code += "/******************************************************************************\n";
  code += " * Variable declarations\n";
  code += " ******************************************************************************/\n\n";

  code += "QStateMachine fsm;              // Global state machine instance\n";
  code += "QMap<QString, QString> inputs;  // Map of input names to values\n";
  code += "QMap<QString, QString> outputs; // Map of output names to values\n";
  code += "bool debugEnabled = false;\n";
  code += "QSet<QTcpSocket*> clientSockets;\n";
  code += "QMap<QString, QVariant> variables;\n";
  code += "QMap<QPair<QString, QString>, QPair<qint64, int>> timers; // [(from,to),(startime,duration)]\n\n";
  code += "QMap<QTcpSocket*, QTimer*> pingTimers; // Tracks pingpong keepalive timers per client\n";
  code += "QSet<QTcpSocket*> awaitingPong;        // Tracks clients waiting for pong\n\n";

  QMap<QString, Variable*> variables = fsm->getVariables();
  if (!variables.isEmpty()) {
    code += "// Custom variables for " + fsm->getName() + "\n";

    for (auto it = variables.constBegin(); it != variables.constEnd(); ++it) {
      Variable* var = it.value();
      code += var->getType() + " " + var->getName() + " = " + var->getValue().toString() + ";\n";
    }
    code += "\n";
  }
  return code;
}

/**
 * @brief Provides logging functions for state transitions, events, and debugging.
 * @return Code section as QString.
 */
QString CodeGenerator::generateRuntimeMonitoring() {
  QString code;

  code += "/******************************************************************************\n";
  code += " * Runtime monitoring and debugging\n";
  code += " ******************************************************************************/\n";

  code += "const QString ANSI_RESET = \"\\033[0m\";\n";
  code += "const QString ANSI_BOLD = \"\\033[1m\";\n\n";

  code += "// Semantic Color Mappings\n";
  code += "const QString COLOR_STATE = \"\\033[38;5;93m\";      // Purple: For state names\n";
  code += "const QString COLOR_TRANSITION = \"\\033[38;5;39m\"; // Blueish: For transition arrows/info\n";
  code += "const QString COLOR_SOURCE = \"\\033[38;5;102m\";    // Gray: For source state names in transitions\n";
  code += "const QString COLOR_TARGET = \"\\033[38;5;84m\";     // Green: For target state names in transitions\n";
  code += "const QString COLOR_COMMAND = \"\\033[38;5;231m\";   // Whitish: For commands, keywords\n";
  code += "const QString COLOR_INPUT = \"\\033[38;5;75m\";      // Cyan: For input names\n";
  code += "const QString COLOR_VALUE = \"\\033[38;5;153m\";     // Light Blue: For variable/input/output values\n";
  code += "const QString COLOR_HEADER = \"\\033[38;5;141m\";    // Dark Purple: For section headers\n\n";

  code += "// Status & Logging Colors\n";
  code += "const QString COLOR_INFO = \"\\033[38;5;39m\";       // Blue: For general info/debug messages\n";
  code += "const QString COLOR_NOTICE = \"\\033[38;5;102m\";    // Grayish: For separators, less important info\n";
  code += "const QString COLOR_WARNING = \"\\033[38;5;220m\";   // Yellow: For warnings\n";
  code += "const QString COLOR_ERROR = \"\\033[38;5;196m\";     // Red: For errors\n";
  code += "const QString COLOR_SUCCESS = \"\\033[38;5;84m\";    // Greener: For success messages\n\n";

  code += "// Timeout Specific Colors\n";
  code += "const QString TIMEOUT_STARTED = \"\\033[38;5;177m\"; // Pinkish: Timeout timer started\n";
  code += "const QString TIMEOUT_EXPIRED = \"\\033[38;5;213m\"; // Magenta: Timeout timer expired\n\n";

  code += "const QString STATE_HEADER = ANSI_BOLD + COLOR_STATE + \"════════ STATE: \" + ANSI_RESET;\n";
  code += "const QString COMMAND_HEADER = ANSI_BOLD + COLOR_COMMAND + \"⟫ COMMAND: \" + ANSI_RESET;\n";
  code += "const QString SECTION_SEPARATOR = COLOR_NOTICE + \"───────────────────────────────────────────────────\" + ANSI_RESET;\n";
  code += "const QString DOUBLE_SEPARATOR = COLOR_TRANSITION + \"═══════════════════════════════════════════════════\" + ANSI_RESET;\n\n";

  code += "/**\n";
  code += " * @brief Prints a log message.\n";
  code += " * @param message Log message to display.\n";
  code += " */\n";
  code += "void log(const QString& message) {\n";
  code += "    QString timeStr = QDateTime::currentDateTime().toString(\"HH:mm:ss.zzz\");\n";
  code += "    qDebug().noquote() << \"[\" << timeStr << \"]\" << message;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Logs state transitions for monitoring.\n";
  code += " * @param stateName State name being entered.\n";
  code += " */\n";
  code += "void logStateChange(const QString& stateName) {\n";
  code += "    log(DOUBLE_SEPARATOR);\n";
  code += "    log(STATE_HEADER + ANSI_BOLD + COLOR_STATE + stateName + ANSI_RESET + \" ENTERED\");\n";
  code += "    log(SECTION_SEPARATOR);\n";
  code += "    log(\"Executing onEntry action for state: \" + ANSI_BOLD + stateName + ANSI_RESET);\n";
  code += "    log(SECTION_SEPARATOR);\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Logs input values for monitoring.\n";
  code += " * @param input Input name.\n";
  code += " * @param value Input value.\n";
  code += " */\n";
  code += "void logInputEvent(const QString& input, const QString& value) {\n";
  code += "    log(\"Input value: \" + ANSI_BOLD + input + ANSI_RESET + \" = \" + COLOR_VALUE + value + ANSI_RESET);\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Logs output values for monitoring.\n";
  code += " * @param output Output name.\n";
  code += " * @param value Output value.\n";
  code += " */\n";
  code += "void logOutputEvent(const QString& output, const QString& value) {\n";
  code += "    log(\"Output value: \" + ANSI_BOLD + output + ANSI_RESET + \" = \" + COLOR_VALUE + value + ANSI_RESET);\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Prints a debug message if debugEnabled is true.\n";
  code += " * @param message Debug message to display.\n";
  code += " */\n";
  code += "void debug(const QString& message) {\n";
  code += "    if (!debugEnabled) return;\n";
  code += "    QString timeStr = QDateTime::currentDateTime().toString(\"HH:mm:ss.zzz\");\n";
  code += "    QString prefix = COLOR_INFO + \"• DEBUG\" + ANSI_RESET + \": \";\n";
  code += "    qDebug().noquote() << \"[\" << timeStr << \"]\" << prefix << message;\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Displays all available commands and valid inputs.\n";
  code += " * @param fsmName Name of the FSM.\n";
  code += " * @param fsmDescription Description of the FSM.\n";
  code += " * @param validInputs Set of valid input names.\n";
  code += " * @param helpLines List of command descriptions to display.\n";
  code += " */\n";
  code += "void showHelp(const QString& fsmName, const QString& fsmDescription, const QSet<QString>& validInputs, const QStringList& helpLines) {\n";
  code += "    log(DOUBLE_SEPARATOR);\n";
  code += "    log(ANSI_BOLD + COLOR_HEADER + \"Machine: \" + ANSI_RESET + COLOR_STATE + fsmName + ANSI_RESET);\n";
  code += "    if (!fsmDescription.isEmpty()) {\n";
  code += "        log(fsmDescription);\n";
  code += "    }\n";
  code += "    log(DOUBLE_SEPARATOR);\n";
  code += "    log(ANSI_BOLD + COLOR_COMMAND + \"AVAILABLE COMMANDS:\" + ANSI_RESET);\n";
  code += "    for (const QString& line : helpLines) {\n";
  code += "        log(line);\n";
  code += "    }\n";
  code += "    log(SECTION_SEPARATOR);\n";
  code += "    if (!validInputs.isEmpty()) {\n";
  code += "        log(ANSI_BOLD + COLOR_INPUT + \"VALID INPUTS:\" + ANSI_RESET);\n";
  code += "        QStringList sortedInputs = validInputs.values();\n";
  code += "        sortedInputs.sort();\n";
  code += "        for (const QString& input : sortedInputs) {\n";
  code += "            log(\"  \" + COLOR_INPUT + input + ANSI_RESET);\n";
  code += "        }\n";
  code += "    }\n";
  code += "    log(SECTION_SEPARATOR);\n";
  code += "}\n\n";

  return code;
}

/**
 * @brief Generate code for a transition.
 * @param transition The transition.
 * @param sourceState Source state.
 * @param targetState Target state.
 * @return Generated C++ code for the transition.
 */
QString CodeGenerator::generateTransitionCode(Transition* transition,
                                              const State* sourceState,
                                              const State* targetState) {
  QString code;
  QString sourceName = const_cast<State*>(sourceState)->getName();
  QString targetName = const_cast<State*>(targetState)->getName();
  QString sourceLower = sourceName.toLower();
  QString targetLower = targetName.toLower();

  QString condition = transition->getCondition();
  QString event = transition->getEvent();

  int delay = transition->isDelayedTransition() ? transition->getDelay() : 0;
  bool hasCondition = !condition.isEmpty();
  bool hasEvent = !event.isEmpty();
  bool hasDelay = delay > 0 || (!transition->getDelayVariableName().isEmpty() && transition->isDelayedTransition());

  static int transitionCounter = 0;
  QString transName = sourceLower + "To" + targetName + "Transition" + QString::number(++transitionCounter);

  code += "    // Create transition: " + sourceName + " → " + targetName;
  if (hasEvent || hasCondition || hasDelay) {
    code += " (";
    if (hasEvent) {
      code += "event: " + event;
    }
    if (hasCondition) {
      if (hasEvent) code += ", ";
      code += "[ " + condition + " ]";
    }
    if (hasDelay) {
      if (hasEvent || hasCondition) code += " ";
      if (!transition->getDelayVariableName().isEmpty())
        code += "@ " + transition->getDelayVariableName();
      else
        code += "@ " + QString::number(delay) + "ms";
    }
    code += ")";
  }
  code += "\n";

  QString delayProvider;
  if (transition->isDelayedTransition() && !transition->getDelayVariableName().isEmpty()) {
    const QString varName = transition->getDelayVariableName();
    delayProvider = "[]() -> int { return " + varName + "; }";
  } else if (hasDelay) {
    delayProvider = "[]() -> int { return " + QString::number(delay) + "; }";
  } else {
    delayProvider = "[]() -> int { return 0; }";
  }

  code += "    GeneratedTransition* " + transName + " = new GeneratedTransition(";
  if (hasEvent && hasCondition) {
    code += "[]() -> bool {\n";
    code += "        return called(\"" + event + "\") && (" + condition + ");\n";
    code += "    }";
  } else if (hasEvent) {
    code += "[]() -> bool {\n";
    code += "        return called(\"" + event + "\");\n";
    code += "    }";
  } else if (hasCondition) {
    code += "[]() -> bool {\n";
    code += "        return " + condition + ";\n";
    code += "    }";
  } else {
    code += "[]() { return true; }";
  }
  code += ", " + delayProvider;
  code += ", \"" + sourceName + "\", \"" + targetName + "\"";
  code += ");\n";
  code += "    " + sourceLower + "State->addTransition(" + transName + ");\n";
  code += "    " + transName + "->setTargetState(" + targetLower + "State);\n\n";
  return code;
}

/**
 * @brief Generates a main function that uses QStateMachine.
 * @param fsm FSM containing the states and transitions.
 * @return Code section as QString.
 */
QString CodeGenerator::generateMainFunction(FSM* fsm) {
  QString code;

  code += "/******************************************************************************\n";
  code += " * Classes and Main function with QStateMachine\n";
  code += " ******************************************************************************/\n";

  State* initial = fsm->getInitialState();
  QMap<QString, State*> allStates = fsm->getStates();

  QString initialStateName = initial ? initial->getName() : "UNKNOWN";

  code += "/**\n";
  code += " * @brief Custom event for input changes.\n";
  code += " */\n";
  code += "class InputEvent : public QEvent {\n";
  code += "public:\n";
  code += "    static const QEvent::Type InputChangedType = static_cast<QEvent::Type>(QEvent::User + 2); // Custom event type for input changes\n";
  code += "    InputEvent(const QString& name, const QString& value) \n";
  code += "        : QEvent(InputChangedType), m_name(name), m_value(value) {}\n";
  code += "    QString name() const { return m_name; }\n";
  code += "    QString value() const { return m_value; }\n\n";

  code += "private:\n";
  code += "    QString m_name;\n";
  code += "    QString m_value;\n";
  code += "};\n\n";

  code += "/**\n";
  code += " * @brief Transition class handling both conditions and delays, generated for runtime.\n";
  code += " */\n";
  code += "class GeneratedTransition : public QAbstractTransition {\n";
  code += "public:\n";
  code += "    /**\n";
  code += "     * @brief Constructor for a transition that handles both conditions and delays.\n";
  code += "     * @param condition A lambda function that evaluates to a boolean.\n";
  code += "     * @param delayFn A lambda function that returns the delay in milliseconds (live value).\n";
  code += "     * @param fromState Source state name (for logging).\n";
  code += "     * @param toState Target state name (for logging).\n";
  code += "     */\n";
  code += "    explicit GeneratedTransition(std::function<bool()> condition = []() { return true; },\n";
  code += "                             std::function<int()> delayFn = []() { return 0; },\n";
  code += "                             const QString& fromState = QString(),\n";
  code += "                             const QString& toState = QString())\n";
  code += "        : m_condition(std::move(condition)),\n";
  code += "          m_delayFn(std::move(delayFn)),\n";
  code += "          m_fromState(fromState),\n";
  code += "          m_toState(toState),\n";
  code += "          m_timer(new QTimer(this)),\n";
  code += "          m_conditionMet(false),\n";
  code += "          m_timerExpired(false),\n";
  code += "          m_initialDelay(-1)\n";
  code += "    {\n";
  code += "        m_timer->setSingleShot(true);\n";
  code += "        connect(m_timer, &QTimer::timeout, this, &GeneratedTransition::triggerTransition);\n";
  code += "    }\n\n";
  code += "    void resetTimerArmed() { m_timerArmed = false; m_initialDelay = -1; }\n";
  code += "    void stopTimer() { if (m_timer && m_timer->isActive()) m_timer->stop(); }\n";
  code += "    QString fromStateName() const { return m_fromState; }\n";
  code += "    QString toStateName() const { return m_toState; }\n\n";
  code += "protected:\n";
  code += "    bool eventTest(QEvent* event) override {\n";
  code += "        if (event->type() == QEvent::User + 1 && m_timerExpired) { // Custom event type\n";
  code += "            m_timerExpired = false;\n";
  code += "            // Re-evaluate the condition in case it changed during the delay\n";
  code += "            if (m_condition()) {\n";
  code += "                return true;\n";
  code += "            } else {\n";
  code += "                m_conditionMet = false;\n";
  code += "                cancelTimerIfActive(\"Condition is no longer met (input or variable changed).\");\n";
  code += "                return false;\n";
  code += "            }\n";
  code += "        }\n";
  code += "        try {\n";
  code += "            m_conditionMet = m_condition();\n";
  code += "            debug(\"Evaluating transition from \" + m_fromState + \" to \" + m_toState + \": \" + (m_conditionMet ? \"true\" : \"false\"));\n";
  code += "            if (!m_conditionMet) {\n";
  code += "                cancelTimerIfActive(\"Condition is no longer met (input or variable changed).\");\n";
  code += "                return false;\n";
  code += "            }\n";
  code += "            if (m_initialDelay == -1) {\n";
  code += "                m_initialDelay = m_delayFn();\n";
  code += "                debug(\"Initial delay for transition \" + m_fromState + \" → \" + m_toState + \": \" + QString::number(m_initialDelay) + \" ms\");\n";
  code += "            }\n";
  code += "            const int effDelay = m_initialDelay;\n";
  code += "            if (effDelay > 0) {\n";
  code += "                if (!m_timerArmed && m_initialDelay == effDelay) {\n";
  code += "                    logTransitionStart(effDelay);\n";
  code += "                    sendTimerEvent(\"timerStart\", m_fromState, m_toState, effDelay);\n";
  code += "                    m_timer->start(effDelay);\n";
  code += "                    m_timerArmed = true;\n";
  code += "                }\n";
  code += "                return false;\n";
  code += "            }\n";
  code += "            return m_conditionMet;\n";
  code += "        } catch (const std::exception& e) {\n";
  code += "            log(\"Error evaluating transition condition: \" + QString::fromStdString(e.what()));\n";
  code += "            return false;\n";
  code += "        } catch (...) {\n";
  code += "            log(\"Unknown error evaluating transition condition\");\n";
  code += "            return false;\n";
  code += "        }\n";
  code += "    }\n\n";
  code += "    void onTransition(QEvent* event) override {\n";
  code += "        Q_UNUSED(event);\n";
  code += "        m_conditionMet = false;\n";
  code += "        m_timerArmed = false;\n";
  code += "        m_timerExpired = false;\n";
  code += "        m_initialDelay = -1;\n";
  code += "    }\n\n";
  code += "private slots:\n";
  code += "    void triggerTransition() {\n";
  code += "        if (m_condition()) {\n";
  code += "            m_timerExpired = true;\n";
  code += "            log(TIMEOUT_EXPIRED + ANSI_BOLD + \"▶ Timeout expired\" + ANSI_RESET + \" for transition \" +\n";
  code += "                COLOR_SOURCE + m_fromState + ANSI_RESET +\n";
  code += "                COLOR_TRANSITION + \" → \" +\n";
  code += "                COLOR_TARGET + m_toState + ANSI_RESET +\n";
  code += "                ANSI_RESET + \" (delay: \" + ANSI_BOLD + QString::number(m_initialDelay) + \" ms)\" + ANSI_RESET);\n";
  code += "            sendTimerEvent(\"timerExpired\", m_fromState, m_toState);\n";
  code += "            QEvent* customEvent = new QEvent(static_cast<QEvent::Type>(QEvent::User + 1)); // Custom event type\n";
  code += "            machine()->postEvent(customEvent);\n";
  code += "        } else {\n";
  code += "            m_conditionMet = false;\n";
  code += "            cancelTimerIfActive(\"Condition became false before timeout expired.\");\n";
  code += "            debug(\"Condition no longer valid after delay for transition \" +\n";
  code += "                  m_fromState + \" → \" + m_toState +\n";
  code += "                  \", not triggering\");\n";
  code += "        }\n";
  code += "    }\n\n";
  code += "private:\n";
  code += "    void cancelTimerIfActive(const QString& reason = QString()) {\n";
  code += "        if (m_timer && m_timer->isActive()) {\n";
  code += "            QString msg = \"Cancelling timer for transition \" + m_fromState + \" → \" + m_toState;\n";
  code += "            if (!reason.isEmpty()) {\n";
  code += "                msg += \": \" + reason;\n";
  code += "            }\n";
  code += "            log(msg);\n";
  code += "            m_timer->stop();\n";
  code += "            m_timerArmed = false;\n";
  code += "            m_initialDelay = -1;\n";
  code += "        }\n";
  code += "    }\n\n";
  code += "    void logTransitionStart(int effDelay) {\n";
  code += "        log(TIMEOUT_STARTED + ANSI_BOLD + \"▶ Timeout started\" + ANSI_RESET + \" for transition \" +\n";
  code += "            COLOR_SOURCE + m_fromState + ANSI_RESET +\n";
  code += "            COLOR_TRANSITION + \" → \" +\n";
  code += "            COLOR_TARGET + m_toState + ANSI_RESET +\n";
  code += "            ANSI_RESET + \" (delay: \" + ANSI_BOLD + QString::number(effDelay) + \" ms)\" + ANSI_RESET);\n";
  code += "        debug(\"Condition met for transition \" +\n";
  code += "              COLOR_SOURCE + m_fromState + ANSI_RESET + \" → \" +\n";
  code += "              COLOR_TARGET + m_toState + ANSI_RESET +\n";
  code += "              \", starting \" + COLOR_VALUE + QString::number(effDelay) + \"ms\" + ANSI_RESET + \" delay timer\");\n";
  code += "    }\n\n";
  code += "    std::function<bool()> m_condition;\n";
  code += "    std::function<int()> m_delayFn;\n";
  code += "    QString m_fromState;\n";
  code += "    QString m_toState;\n";
  code += "    QTimer* m_timer;\n";
  code += "    bool m_conditionMet;\n";
  code += "    bool m_timerArmed = false;\n";
  code += "    bool m_timerExpired = false;\n";
  code += "    int m_initialDelay = -1;\n";
  code += "};\n\n";

  code += "/**\n";
  code += " * @brief Zastaví všechny aktivní timeouty pro odchozí přechody z daného stavu (kromě self-transitions).\n";
  code += " */\n";
  code += "void clearOutgoingTimers(const QString& stateName) {\n";
  code += "    debug(QString(\"clearOutgoingTimers('%1')\").arg(stateName));\n";
  code += "    for (QAbstractTransition* t : fsm.findChildren<QAbstractTransition*>()) {\n";
  code += "        auto ut = dynamic_cast<GeneratedTransition*>(t);\n";
  code += "        if (!ut) continue;\n";
  code += "        const QString& from = ut->fromStateName();\n";
  code += "        const QString& to = ut->toStateName();\n";
  code += "        if (from == stateName && from != to) {\n";
  code += "            ut->resetTimerArmed();\n";
  code += "            ut->stopTimer();\n";
  code += "            debug(QString(\"Stopped timer and reset for transition %1 → %2\").arg(from, to));\n";
  code += "        }\n";
  code += "    }\n";
  code += "}\n\n";

  code += "/**\n";
  code += " * @brief Main function that uses QStateMachine for state management.\n";
  code += " */\n";
  code += "int main(int argc, char *argv[]) {\n";
  code += "    QCoreApplication app(argc, argv);\n";
  code += "    QTcpServer server;\n";
  code += "    const char* FSM_XML = R\"xml(\n" + fsm->getXml() + "\n)xml\";\n";
  code += "    \n";
  code += "    // --host and --port arguments\n";
  code += "    QString hostStr = \"127.0.0.1\";\n";
  code += "    quint16 port = 54323;\n";
  code += "    for (int i = 1; i < argc; ++i) {\n";
  code += "        QString arg = argv[i];\n";
  code += "        if (arg == \"--host\" && i + 1 < argc) {\n";
  code += "            hostStr = argv[++i];\n";
  code += "        } else if (arg == \"--port\" && i + 1 < argc) {\n";
  code += "            bool ok = false;\n";
  code += "            int p = QString(argv[++i]).toInt(&ok);\n";
  code += "            if (ok && p > 1024 && p < 65536) { port = static_cast<quint16>(p); }\n";
  code += "        }\n";
  code += "    }\n";
  code += "    QHostAddress hostAddr;\n";
  code += "    if (!hostAddr.setAddress(hostStr)) {\n";
  code += "        log(\"Invalid host address specified, defaulting to 127.0.0.1\");\n";
  code += "        hostAddr = QHostAddress::LocalHost;\n";
  code += "    }\n";
  code += "    \n";
  code += "    qDebug().noquote() << \"\\n\" + DOUBLE_SEPARATOR;\n";
  code += "    qDebug().noquote() << ANSI_BOLD + COLOR_HEADER + \"✧ ✧ ✧  OBLIVION STATE MACHINE  ✧ ✧ ✧\" + ANSI_RESET;\n";
  code += "    qDebug().noquote() << COLOR_TRANSITION + \"     we looove finite state machines (｡◕‿‿◕｡)\" + ANSI_RESET;\n";
  code += "    qDebug().noquote() << DOUBLE_SEPARATOR + \"\\n\";\n";
  code += "    \n";
  code += "    debug(\"Starting FSM application with QStateMachine\");\n";
  code += "    debug(\"State machine name: \" + ANSI_BOLD + COLOR_STATE + \"" + fsm->getName() + "\" + ANSI_RESET);\n";

  code += "    std::signal(SIGINT, [](int) {\n";
  code += "        log(DOUBLE_SEPARATOR);\n";
  code += "        log(ANSI_BOLD + COLOR_WARNING + \"SIGINT (Ctrl+C) recieved. Exiting application.\" + ANSI_RESET);\n";
  code += "        log(DOUBLE_SEPARATOR);\n";
  code += "        broadcastShutdownEvent(\"Server is shutting down due to SIGINT (Ctrl+C). All clients will be disconnected.\");\n";
  code += "        closeAndCleanupAllSockets();\n";
  code += "        QCoreApplication::quit();\n";
  code += "    });\n\n";

  QSet<QString> inputNames = fsm->getInputs();
  QSet<QString> outputNames = fsm->getOutputs();

  code += "    // Initialize inputs and outputs\n";
  for (const QString& input : inputNames) {
    code += "    inputs[QStringLiteral(\"" + input.trimmed() + "\")] = QString();\n";
    code += "    getEventFlags()[QStringLiteral(\"" + input.trimmed() + "\")] = false;\n";
  }

  for (const QString& output : outputNames) {
    code += "    outputs[QStringLiteral(\"" + output.trimmed() + "\")] = QString();\n";
  }
  code += "\n";

  code += "    QSet<QString> validInputNames;\n";
  for (const QString& input : inputNames) {
    code += "    validInputNames.insert(QStringLiteral(\"" + input.trimmed() + "\"));\n";
  }
  code += "\n";

  code += "    const QStringList helpLines = {\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"input_name=value\").leftJustified(26) + ANSI_RESET + \"- Set an input value\",\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"input_name\").leftJustified(26) + ANSI_RESET + \"- Call an input\",\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"/status\").leftJustified(26) + ANSI_RESET + \"- Show the current system state\",\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"/help\").leftJustified(26) + ANSI_RESET + \"- Show this help message\",\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"/exit\").leftJustified(26) + ANSI_RESET + \"- Exit the application\",\n";
  code += "        \"• \" + ANSI_BOLD + QString(\"/debugon /debugoff\").leftJustified(26) + ANSI_RESET + \"- Turn debug statements on/off\"\n";
  code += "    };\n\n";

  code += "    fsm.setObjectName(\"" + fsm->getName() + "\");\n\n";
  code += "    fsm.setProperty(\"description\", \"" + fsm->getComment() + "\");\n\n";

  code += "    debug(\"Creating states...\");\n";

  code += "    static QString globalPrevStateName;\n";
  for (auto it = allStates.begin(); it != allStates.end(); ++it) {
    State* state = it.value();
    QString stateName = state->getName();
    QString stateLower = stateName.toLower();

    code += "    QState* " + stateLower + "State = new QState(&fsm);\n";
    code += "    " + stateLower + "State->setObjectName(\"" + stateName + "\");\n";

    QString onEntry = state->getCode();
    code += "    // QState::entered lambda: handles state entry logic, including logging, updating state, and running onEntry actions.\n";
    code += "    QObject::connect(" + stateLower + "State, &QState::entered, [=]() {\n";
    code += "        QString prevStateName = globalPrevStateName;\n";
    code += "        QString currentStateName = \"" + stateName + "\";\n";
    code += "        if (prevStateName != currentStateName) {\n";
    code += "            qint64 now = QDateTime::currentDateTime().toMSecsSinceEpoch();\n";
    code += "            " + stateLower + "State->setProperty(\"entryTime\", QVariant::fromValue(now));\n";
    code += "            clearOutgoingTimers(\"" + stateName + "\");\n";
    code += "        }\n";
    code += "        globalPrevStateName = currentStateName;\n";
    code += "        log(DOUBLE_SEPARATOR);\n";
    code += "        log(STATE_HEADER + ANSI_BOLD + COLOR_STATE + \"" + stateName + "\" + ANSI_RESET + \" ENTERED\");\n";
    code += "        log(SECTION_SEPARATOR);\n";
    code += "        for (QTcpSocket* clientSocket : clientSockets) {\n";
    code += "            if (clientSocket->state() == QAbstractSocket::ConnectedState) {\n";
    code += "                QString stateMsg = QString(\"<event type=\\\"stateChange\\\"><name>%1</name></event>\").arg(currentStateName);\n";
    code += "                clientSocket->write(buildEvent(stateMsg));\n";
    code += "                clientSocket->flush();\n";
    code += "            }\n";
    code += "        }\n";
    if (!onEntry.isEmpty()) {
      code += "        log(\"Executing onEntry action for state: \" + ANSI_BOLD + \"" + stateName + "\" + ANSI_RESET);\n";
      code += "        " + onEntry + "\n";
    }
    code += "        log(SECTION_SEPARATOR);\n";
    code += "        log(\" \");\n";
    code += "    });\n\n";
  }

  code += "    fsm.setInitialState(" + initialStateName.toLower() + "State);\n";
  code += "    debug(\"Initial state set to \" + ANSI_BOLD + COLOR_TARGET + \"" + initialStateName + "\" + ANSI_RESET);\n\n";

  code += "    debug(\"Setting up transitions...\");\n";

  for (auto stateIt = allStates.begin(); stateIt != allStates.end(); ++stateIt) {
    State* sourceState = stateIt.value();
    QString sourceName = sourceState->getName();
    QList<Transition*> transitions = fsm->getTransitionsFrom(sourceState);
    for (Transition* transition : transitions) {
      State* targetState = transition->getTo();
      if (!targetState) {
        continue;
      }
      QString targetName = targetState->getName();
      code += generateTransitionCode(transition, sourceState, targetState);
    }
  }

  code += "    showHelp(fsm.objectName(), fsm.property(\"description\").toString(), validInputNames, helpLines);\n";
  code += "    qDebug().noquote() << \"\";\n\n";

  code += "    FILE* terminalInput = fdopen(dup(STDIN_FILENO), \"r\");\n";
  code += "    if (!terminalInput) {\n";
  code += "        debug(\"Error: Could not open terminal input\");\n";
  code += "        return 1;\n";
  code += "    }\n\n";

  code += "    int terminalFd = fileno(terminalInput);\n";
  code += "    QSocketNotifier* inputNotifier = new QSocketNotifier(terminalFd, QSocketNotifier::Read);\n\n";

  code += "    // QSocketNotifier::activated lambda: terminal input processing\n";
  code += "    QObject::connect(inputNotifier, &QSocketNotifier::activated, [&]() {\n";
  code += "        char buffer[256];\n";
  code += "        if (fgets(buffer, sizeof(buffer), terminalInput)) {\n";
  code += "            QString inputLine = QString::fromLocal8Bit(buffer).trimmed();\n";
  code += "            \n";
  code += "            if (inputLine.isEmpty()) { return; }\n";
  code += "            \n";
  code += "            if (inputLine == \"/exit\") {\n";
  code += "                log(\"Quit command received. Terminating application.\");\n";
  code += "                broadcastShutdownEvent(\"Server is shutting down due to /exit command. All clients will be disconnected.\");\n";
  code += "                closeAndCleanupAllSockets();\n";
  code += "                QCoreApplication::quit();\n";
  code += "                return;\n";
  code += "            }\n";
  code += "            \n";
  code += "            if (inputLine == \"/help\") {\n";
  code += "                showHelp(fsm.objectName(), fsm.property(\"description\").toString(), validInputNames, helpLines);\n";
  code += "                return;\n";
  code += "            }\n";
  code += "            \n";
  code += "            if (inputLine == \"/status\") {\n";
  code += "                QString currentState = fsm.configuration().isEmpty() ? \"UNKNOWN\" : (*fsm.configuration().begin())->objectName();\n";
  code += "                log(\"Current state: \" + ANSI_BOLD + COLOR_STATE + currentState + ANSI_RESET);\n";
  code += "                // Show debug state\n";
  code += "                log(SECTION_SEPARATOR);\n";
  code += "                log(ANSI_BOLD + COLOR_HEADER + \"DEBUG STATE:\" + ANSI_RESET);\n";
  code += "                log(QString(\"  Debug output is \") + (debugEnabled ? (COLOR_SUCCESS + \"ENABLED\" + ANSI_RESET) : (COLOR_WARNING + \"DISABLED\" + ANSI_RESET)));\n";
  code += "                // Show client connection status\n";
  code += "                log(SECTION_SEPARATOR);\n";
  code += "                log(ANSI_BOLD + COLOR_HEADER + \"CLIENT CONNECTIONS:\" + ANSI_RESET);\n";
  code += "                for (QTcpSocket* clientSocket : clientSockets) {\n";
  code += "                    if (clientSocket->state() == QAbstractSocket::ConnectedState) {\n";
  code += "                        log(\"  \" + COLOR_SUCCESS + \"Client connected\" + ANSI_RESET + \" (\" + clientSocket->peerAddress().toString() + \")\");\n";
  code += "                    } else {\n";
  code += "                        log(\"  \" + COLOR_WARNING + \"Client disconnected\" + ANSI_RESET);\n";
  code += "                    }\n";
  code += "                }\n";
  code += "                // Show inputs\n";
  code += "                log(SECTION_SEPARATOR);\n";
  code += "                log(ANSI_BOLD + COLOR_HEADER + \"INPUTS:\" + ANSI_RESET);\n";
  code += "                for (auto it = inputs.constBegin(); it != inputs.constEnd(); ++it) {\n";
  code += "                    log(\"  \" + COLOR_COMMAND + it.key() + ANSI_RESET + \" = \" + COLOR_VALUE + it.value() + ANSI_RESET);\n";
  code += "                }\n";
  code += "                // Show outputs\n";
  code += "                log(SECTION_SEPARATOR);\n";
  code += "                log(ANSI_BOLD + COLOR_HEADER + \"OUTPUTS:\" + ANSI_RESET);\n";
  code += "                for (auto it = outputs.constBegin(); it != outputs.constEnd(); ++it) {\n";
  code += "                    log(\"  \" + COLOR_COMMAND + it.key() + ANSI_RESET + \" = \" + COLOR_VALUE + it.value() + ANSI_RESET);\n";
  code += "                }\n";
  code += "                // Show internal variables\n";
  code += "                log(SECTION_SEPARATOR);\n";
  code += "                log(ANSI_BOLD + COLOR_HEADER + \"INTERNAL VARIABLES:\" + ANSI_RESET);\n";
  QMap<QString, Variable*> variables = fsm->getVariables();
  for (auto it = variables.constBegin(); it != variables.constEnd(); ++it) {
    Variable* var = it.value();
    QString varName = var->getName();
    code += "                log(\"  \" + COLOR_COMMAND + \"" + varName + "\" + ANSI_RESET + \" = \" + COLOR_VALUE + QVariant::fromValue(" + varName + ").toString() + ANSI_RESET);\n";
  }
  code += "                log(SECTION_SEPARATOR);\n";
  code += "                return;\n";
  code += "            }\n";
  code += "            \n";
  code += "            if (inputLine == \"/debugon\") {\n";
  code += "                debugEnabled = true;\n";
  code += "                log(\"Debug output enabled.\");\n";
  code += "                return;\n";
  code += "            }\n";
  code += "            if (inputLine == \"/debugoff\") {\n";
  code += "                debugEnabled = false;\n";
  code += "                log(\"Debug output disabled.\");\n";
  code += "                return;\n";
  code += "            }\n";
  code += "            \n";
  code += "            QRegularExpression inputRegex(\"^(\\\\w+)(?:=(.*))?$\");\n";
  code += "            QRegularExpressionMatch match = inputRegex.match(inputLine);\n";
  code += "            \n";
  code += "            if (match.hasMatch()) {\n";
  code += "                QString name = match.captured(1);\n";
  code += "                QString value = match.captured(2);\n";
  code += "                \n";
  code += "                if (!validInputNames.contains(name)) {\n";
  code += "                    log(\"Invalid input name: \" + ANSI_BOLD + COLOR_ERROR + name + ANSI_RESET);\n";
  code += "                    return;\n";
  code += "                }\n";
  code += "                \n";
  code += "                if (!value.isEmpty()) {\n";
  code += "                    // SET mode: store the new value and trigger event\n";
  code += "                    debug(\"SET MODE for '\" + name + \"' with value '\" + value + \"'\");\n";
  code += "                    inputs[name] = value;\n";
  code += "                    logInputEvent(name, value);\n";
  code += "                    setInputCalled(name);\n";
  code += "                    fsm.postEvent(new InputEvent(name, value));\n";
  code += "                } else {\n";
  code += "                    // CALL mode: treat as pure event without changing stored value\n";
  code += "                    debug(\"CALL MODE for '\" + name + \"'\");\n";
  code += "                    QString lastValue = inputs.contains(name) ? inputs[name] : QString();\n";
  code += "                    logInputEvent(name, lastValue);\n";
  code += "                    setInputCalled(name);\n";
  code += "                    fsm.postEvent(new InputEvent(name, lastValue));\n";
  code += "                }\n";
  code += "            } else {\n";
  code += "                log(\"Unrecognized command: \" + ANSI_BOLD + COLOR_ERROR + inputLine + ANSI_RESET);\n";
  code += "            }\n";
  code += "        } else {\n";
  code += "            log(DOUBLE_SEPARATOR);\n";
  code += "            log(ANSI_BOLD + COLOR_WARNING + \"EOF (Ctrl+D) received. Exiting application.\" + ANSI_RESET);\n";
  code += "            log(DOUBLE_SEPARATOR);\n";
  code += "            if (terminalInput) {\n";
  code += "                fclose(terminalInput);\n";
  code += "                terminalInput = nullptr;\n";
  code += "            }\n";
  code += "            broadcastShutdownEvent(\"Server is shutting down due to EOF (Ctrl+D) on terminal. All clients will be disconnected.\");\n";
  code += "            closeAndCleanupAllSockets();\n";
  code += "            QCoreApplication::quit();\n";
  code += "        }\n";
  code += "    });\n\n";

  code += "    // TCP communication\n";
  code += "    // QTcpServer::newConnection lambda\n";
  code += "    QObject::connect(&server, &QTcpServer::newConnection, [&]() {\n";
  code += "        while (server.hasPendingConnections()) {\n";
  code += "            QTcpSocket* socket = server.nextPendingConnection();\n";
  code += "            clientSockets.insert(socket);\n";
  code += "            log(\"Client connected from \" + socket->peerAddress().toString());\n";
  code += "            // QTcpSocket::readyRead lambda: reads data from the socket.\n";
  code += "            QObject::connect(socket, &QTcpSocket::readyRead, [socket, FSM_XML](void) {\n";
  code += "                while (socket->canReadLine()) {\n";
  code += "                    QString line = QString::fromUtf8(socket->readLine()).trimmed();\n";
  code += "                    debug(\"TCP: Received line: \" + line);\n";
  code += "                    if (line.isEmpty()) { continue; }\n";
  code += "                    if (!line.startsWith(\"<\")) {\n";
  code += "                        debug(\"TCP: Non-XML command received: \" + line);\n";
  code += "                        sendError(ERR_MALFORMED_XML, \"Malformed XML\", socket);\n";
  code += "                        continue;\n";
  code += "                    }\n";
  code += "                    QDomDocument doc;\n";
  code += "                    if (!doc.setContent(line)) {\n";
  code += "                        debug(\"TCP: Malformed XML received: \" + line);\n";
  code += "                        sendError(ERR_MALFORMED_XML, \"Malformed XML\", socket);\n";
  code += "                        continue;\n";
  code += "                    }\n";
  code += "                    QDomElement root = doc.documentElement();\n";
  code += "                    QString type = root.attribute(\"type\");\n";
  code += "                    if (type == \"set\") {\n";
  code += "                        QString name = root.firstChildElement(\"name\").text();\n";
  code += "                        QString value = root.firstChildElement(\"value\").text();\n";
  code += "                        if (inputs.contains(name)) {\n";
  code += "                            inputs[name] = value;\n";
  code += "                            setInputCalled(name);\n";
  code += "                            fsm.postEvent(new InputEvent(name, value));\n";
  code += "                            log(\"Input '\" + name + \"' set to '\" + value + \"' via TCP\");\n";
  code += "                        } else {\n";
  code += "                            debug(\"TCP: Unknown input '\" + name + \"' in set command\");\n";
  code += "                            sendError(ERR_UNKNOWN_INPUT, \"Unknown input\", socket);\n";
  code += "                        }\n";
  code += "                        continue;\n";
  code += "                    } else if (type == \"call\") {\n";
  code += "                        QString name = root.firstChildElement(\"name\").text();\n";
  code += "                        if (inputs.contains(name)) {\n";
  code += "                            setInputCalled(name);\n";
  code += "                            fsm.postEvent(new InputEvent(name, inputs[name]));\n";
  code += "                            log(\"Input '\" + name + \"' called via TCP\");\n";
  code += "                        } else {\n";
  code += "                            debug(\"TCP: Unknown input '\" + name + \"' in call command\");\n";
  code += "                            sendError(ERR_UNKNOWN_INPUT, \"Unknown input\", socket);\n";
  code += "                        }\n";
  code += "                        continue;\n";
  code += "                    } else if (type == \"status\") {\n";
  code += "                        QString state = fsm.configuration().isEmpty()\n";
  code += "                            ? \"UNKNOWN\"\n";
  code += "                            : (*fsm.configuration().begin())->objectName();\n";
  code += "                        QString statusXml = generateStatusXml(state);\n";
  code += "                        QByteArray msg = buildEvent(statusXml);\n";
  code += "                        socket->write(msg);\n";
  code += "                        socket->flush();\n";
  code += "                        debug(\"TCP: Sent status XML\");\n";
  code += "                        continue;\n";
  code += "                    } else if (type == \"help\") {\n";
  code += "                        QString helpMsg = \"<event type=\\\"log\\\"><message>Supported commands: set, call, status, reqFSM, help, disconnect, shutdown</message></event>\";\n";
  code += "                        socket->write(buildEvent(helpMsg));\n";
  code += "                        socket->flush();\n";
  code += "                        debug(\"TCP: Sent help message\");\n";
  code += "                        continue;\n";
  code += "                    } else if (type == \"reqFSM\") {\n";
  code += "                        QString fsmMsgLine = QString::fromUtf8(FSM_XML).replace('\\n', ' ').replace('\\r', ' ');\n";
  code += "                        QString fsmMsg = QString(\"<event type=\\\"fsm\\\"><model><![CDATA[%1]]></model></event>\").arg(fsmMsgLine);\n";
  code += "                        socket->write(buildEvent(fsmMsg));\n";
  code += "                        socket->flush();\n";
  code += "                        debug(\"TCP: FSM model XML sent to client\");\n";
  code += "                        continue;\n";
  code += "                    } else if (type == \"disconnect\") {\n";
  code += "                        QString disconnectMsg = \"<event type=\\\"disconnect\\\"><message>Disconnecting client</message></event>\";\n";
  code += "                        socket->write(buildEvent(disconnectMsg));\n";
  code += "                        socket->flush();\n";
  code += "                        socket->disconnectFromHost();\n";
  code += "                        debug(\"TCP: Client requested disconnect via socket communication\");\n";
  code += "                        continue;\n";
  code += "                    } else if (type == \"shutdown\") {\n";
  code += "                        broadcastShutdownEvent(\"Server is shutting down due to a TCP shutdown command. All clients will be disconnected.\");\n";
  code += "                        log(\"Shutdown command received via socket communication. Shutting down server.\");\n";
  code += "                        closeAndCleanupAllSockets();\n";
  code += "                        QCoreApplication::quit();\n";
  code += "                        continue;\n";
  code += "                    } else if (type == \"pong\") {\n";
  code += "                        if (awaitingPong.contains(socket)) {\n";
  code += "                            awaitingPong.remove(socket);\n";
  code += "                            if (pingTimers.contains(socket)) {\n";
  code += "                                QTimer* t = pingTimers.take(socket);\n";
  code += "                                if (t) { t->stop(); t->deleteLater(); }\n";
  code += "                            }\n";
  code += "                            debug(\"Received pong from a client.\");\n";
  code += "                        }\n";
  code += "                        continue;\n";
  code += "                    } else {\n";
  code += "                        debug(\"TCP: Unknown XML command received: \" + type);\n";
  code += "                        sendError(ERR_UNKNOWN_COMMAND, \"Unknown command\", socket);\n";
  code += "                        continue;\n";
  code += "                    }\n";
  code += "                }\n";
  code += "            });\n\n";

  code += "            // QTcpSocket::disconnected lambda\n";
  code += "            QObject::connect(socket, &QTcpSocket::disconnected, [socket]() {\n";
  code += "                log(\"Client disconnected\");\n";
  code += "                cleanupSocket(socket);\n";
  code += "            });\n\n";

  code += "            // QTcpSocket::error lambda\n";
  code += "            // Done this way to avoid ambiguity because in Qt5.9 there are multiple overloaded error signals\n";
  code += "            QObject::connect(socket,\n";
  code += "                 // Explicitly choosing the right signal overload\n";
  code += "                static_cast<void (QTcpSocket::*)(QAbstractSocket::SocketError)>(&QTcpSocket::error),\n";
  code += "                [socket](QAbstractSocket::SocketError socketError) {\n";
  code += "                    log(QString(\"Socket error occurred: %1\").arg(socket->errorString()));\n";
  code += "                    cleanupSocket(socket);\n";
  code += "                }\n";
  code += "            );\n";
  code += "        }\n";
  code += "    });\n";

  code += "    QTimer* pingIntervalTimer = new QTimer(&app);\n";
  code += "    pingIntervalTimer->setInterval(20000); // 20s \n";
  code += "    // QTimer::timeout (pingIntervalTimer lambda: Periodically sends ping messages to all clients for keepalive mechanism.\n";
  code += "    QObject::connect(pingIntervalTimer, &QTimer::timeout, [&]() {\n";
  code += "        for (QTcpSocket* clientSocket : clientSockets) {\n";
  code += "            if (!awaitingPong.contains(clientSocket)) {\n";
  code += "                // Send ping\n";
  code += "                QString pingMsg = \"<event type=\\\"ping\\\"/>\";\n";
  code += "                clientSocket->write(buildEvent(pingMsg));\n";
  code += "                clientSocket->flush();\n";
  code += "                awaitingPong.insert(clientSocket);\n";
  code += "                debug(\"Sent ping to a client.\");\n\n";

  code += "                // Expect pong\n";
  code += "                QTimer* pongTimer = new QTimer(clientSocket);\n";
  code += "                pongTimer->setSingleShot(true);\n";
  code += "                // QTimer::timeout (pongTimer): Handles keepalive timeout for individual clients.\n";
  code += "                QObject::connect(pongTimer, &QTimer::timeout, [clientSocket]() {\n";
  code += "                    debug(\"A client timed out.\");\n";
  code += "                    QString shutdownMsg = \"<event type=\\\"shutdown\\\"><message>Keepalive timeout</message></event>\";\n";
  code += "                    clientSocket->write(buildEvent(shutdownMsg));\n";
  code += "                    clientSocket->flush();\n";
  code += "                    cleanupSocket(clientSocket);\n";
  code += "                });\n";
  code += "                pingTimers[clientSocket] = pongTimer;\n";
  code += "                pongTimer->start(10000); // 10 s\n";
  code += "            }\n";
  code += "        }\n";
  code += "    });\n";
  code += "    pingIntervalTimer->start();\n";

  code += "    debug(ANSI_BOLD + COLOR_HEADER + \"INITIALIZING STATE MACHINE\" + ANSI_RESET);\n";
  code += "    fsm.start();\n";
  code += "    debug(COLOR_SUCCESS + \"✓ Transition engine activated successfully\\n\\n\" + ANSI_RESET);\n";
  code += "    int result = app.exec();\n";
  code += "    debug(\"Application terminated with code \" + QString::number(result));\n";
  code += "    return result;\n";
  code += "}\n";

  return code;
}
